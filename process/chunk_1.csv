user_id,problem_id,language,submission_id,cpu_time,memory,status,code,improvement_frac,code_v0_loc,code_v1_loc,original_language,filename_ext
u116766943,p00849,C++,s624998539,9370.0,1232.0,Time Limit Exceeded,"#include<bits/stdc++.h>



#define REP(i,s,n) for(int i=s;i<n;i++)

#define rep(i,n) REP(i,0,n)



using namespace std;



const int IINF = INT_MAX;



int H,W,mini,field[10][10],prev[10][10],mindist[10][10],nfield[10][10],mindist2[10][10],m1[10][10],m2[10][10];

vector<int> sp[2];

bool visited[10][10];

int dx[] = {0,1,0,-1};

int dy[] = {1,0,-1,0};

bool X[10], Y[10];



bool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }



void simulate_min(int dist[10][10],int f[10][10],int s){

  rep(i,H) rep(j,W) dist[i][j] = IINF;

  dist[s/W][s%W] = 0;

  deque<int> deq;

  deq.push_back(s);

  while( !deq.empty() ){

    int cur = deq.front(); deq.pop_front();

    int x = cur % W, y = cur / W;

    rep(i,4){

      int nx = x + dx[i], ny = y + dy[i];

      if( !isValid(nx,ny) ) continue;

      if( f[ny][nx] != 0 && f[ny][nx] != f[s/W][s%W] ) continue;

      if( dist[ny][nx] == IINF ) {

        dist[ny][nx] = dist[y][x] + 1;

        deq.push_back(nx+ny*W);

      }

    }

  }

}





void dfs(int x,int y,int cost,int f[10][10],int ep,deque<int> &path,int F,int S,int prev){



  if( x + y * W == ep ) {

    rep(i,H) rep(j,W) nfield[i][j] = field[i][j];

    rep(i,path.size()) nfield[path[i]/W][path[i]%W] = 1;

    simulate_min(mindist2,nfield,sp[S][0]);

    if( mindist2[sp[S][1]/W][sp[S][1]%W] == IINF ) return;

    mini = min(mini,(int)path.size()-1+mindist2[sp[S][1]/W][sp[S][1]%W]);

    return;

  }

  if( cost >= mini ) return;

  if( m2[sp[S][1]/W][sp[S][1]%W] + cost >= mini ) return;



  int cnt = 0;

  rep(i,4) {

    int nx = x + dx[i], ny = y + dy[i];

    if( !isValid(nx,ny) ) continue;

    cnt += visited[ny][nx];

 }

  if( cnt >= 2 ) return;



  {

    rep(i,4){

      int nx = x, ny = y;

      nx += dx[i], ny += dy[i];

      if( !isValid(nx,ny) ) continue;

      if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) continue;

      if( visited[ny][nx] ) continue;

      while(1){

        nx += dx[i], ny += dy[i];

        if( !isValid(nx,ny) ) break;

        if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) break;

        if( X[nx] || Y[ny] ) break;

        if( visited[ny][nx] ) return;

      }

    }

  }





  rep(i,4) {

    if( i == (prev+2) % 4 ) continue;

    int nx = x + dx[i], ny = y + dy[i];

    if( !isValid(nx,ny) ) continue;

    if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) continue;

    if( visited[ny][nx] ) continue;

    visited[ny][nx] = true;

    path.push_back(nx+ny*W);

    dfs(nx,ny,cost+1,f,ep,path,F,S,i);

    path.pop_back();

    visited[ny][nx] = false;

  }





}



int compute(int F,int S){

  rep(i,H) rep(j,W) visited[i][j] = false;

  deque<int> path;

  path.push_back(sp[F][0]);

  visited[sp[F][0]/W][sp[F][0]%W] = true;

  simulate_min(m1,field,sp[F][0]);

  simulate_min(m2,field,sp[S][0]);

  dfs(sp[F][0]%W,sp[F][0]/W,0,field,sp[F][1],path,F,S,-IINF);

}



int main(){

  while( cin >> H >> W, H|W ){

    rep(i,2) sp[i].clear();

    rep(i,10) X[i] = Y[i] = false;

    rep(i,H) rep(j,W) {

      cin >> field[i][j];

      if( field[i][j] == 1 ) X[j] = true, Y[i] = true;

      if( field[i][j] == 2 ) sp[0].push_back(j+i*W), X[j] = Y[i] = true;

      if( field[i][j] == 3 ) sp[1].push_back(j+i*W), X[j] = Y[i] = true;

    }

    mini = IINF;



    compute(0,1);

    if( mini == IINF ) puts(""0"");

    else cout << mini << endl;

  }

  return 0;

}",1.28,122.0,127.0,C++,cpp
u116766943,p00849,C++,s546809015,9250.0,1228.0,Time Limit Exceeded,"#include<bits/stdc++.h>



#define REP(i,s,n) for(int i=s;i<n;i++)

#define rep(i,n) REP(i,0,n)



using namespace std;



const int IINF = INT_MAX;



int H,W,mini,field[10][10],prev[10][10],mindist[10][10],nfield[10][10],mindist2[10][10],m1[10][10],m2[10][10];

vector<int> sp[2];

bool visited[10][10];

int dx[] = {0,1,0,-1};

int dy[] = {1,0,-1,0};

bool X[10], Y[10];



bool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }



void simulate_min(int dist[10][10],int f[10][10],int s){

  rep(i,H) rep(j,W) dist[i][j] = IINF;

  dist[s/W][s%W] = 0;

  deque<int> deq;

  deq.push_back(s);

  while( !deq.empty() ){

    int cur = deq.front(); deq.pop_front();

    int x = cur % W, y = cur / W;

    rep(i,4){

      int nx = x + dx[i], ny = y + dy[i];

      if( !isValid(nx,ny) ) continue;

      if( f[ny][nx] != 0 && f[ny][nx] != f[s/W][s%W] ) continue;

      if( dist[ny][nx] == IINF ) {

        dist[ny][nx] = dist[y][x] + 1;

        deq.push_back(nx+ny*W);

      }

    }

  }

}





void dfs(int x,int y,int cost,int f[10][10],int ep,deque<int> &path,int F,int S,int prev){



  if( cost >= mini ) return;

  if( m2[sp[S][1]/W][sp[S][1]%W] + cost >= mini ) return;











  if( x + y * W == ep ) {

    rep(i,H) rep(j,W) nfield[i][j] = field[i][j];

    rep(i,path.size()) nfield[path[i]/W][path[i]%W] = 1;

    simulate_min(mindist2,nfield,sp[S][0]);

    if( mindist2[sp[S][1]/W][sp[S][1]%W] == IINF ) return;

    mini = min(mini,(int)path.size()-1+mindist2[sp[S][1]/W][sp[S][1]%W]);

    return;

  }

  int cnt = 0;

  rep(i,4) {

    int nx = x + dx[i], ny = y + dy[i];

    if( !isValid(nx,ny) ) continue;

    cnt += visited[ny][nx];

 }

  if( cnt >= 2 ) return;





  {

    rep(i,4){

      int nx = x, ny = y;

      nx += dx[i], ny += dy[i];

      if( !isValid(nx,ny) ) continue;

      if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) continue;

      if( visited[ny][nx] ) continue;

      while(1){

        nx += dx[i], ny += dy[i];

        if( !isValid(nx,ny) ) break;

        if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) break;

        if( X[nx] || Y[ny] ) break;

        if( visited[ny][nx] ) return;

      }

    }

  }





  rep(i,4) {

    if( i == (prev+2) % 4 ) continue;

    int nx = x + dx[i], ny = y + dy[i];

    if( !isValid(nx,ny) ) continue;

    if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) continue;

    if( visited[ny][nx] ) continue;

    visited[ny][nx] = true;

    path.push_back(nx+ny*W);

    dfs(nx,ny,cost+1,f,ep,path,F,S,i);

    path.pop_back();

    visited[ny][nx] = false;

  }





}



int compute(int F,int S){

  rep(i,H) rep(j,W) visited[i][j] = false;

  deque<int> path;

  path.push_back(sp[F][0]);

  visited[sp[F][0]/W][sp[F][0]%W] = true;

  simulate_min(m1,field,sp[F][0]);

  simulate_min(m2,field,sp[S][0]);

  dfs(sp[F][0]%W,sp[F][0]/W,0,field,sp[F][1],path,F,S,-IINF);

}



int main(){

  while( cin >> H >> W, H|W ){

    rep(i,2) sp[i].clear();

    rep(i,10) X[i] = Y[i] = false;

    rep(i,H) rep(j,W) {

      cin >> field[i][j];

      if( field[i][j] == 1 ) X[j] = true, Y[i] = true;

      if( field[i][j] == 2 ) sp[0].push_back(j+i*W), X[j] = Y[i] = true;

      if( field[i][j] == 3 ) sp[1].push_back(j+i*W), X[j] = Y[i] = true;

    }

    mini = IINF;



    compute(0,1);

    if( mini == IINF ) puts(""0"");

    else cout << mini << endl;

  }

  return 0;

}",1.28,122.0,127.0,C++,cpp
u116766943,p00849,C++,s546809015,9250.0,1228.0,Time Limit Exceeded,"#include<bits/stdc++.h>



#define REP(i,s,n) for(int i=s;i<n;i++)

#define rep(i,n) REP(i,0,n)



using namespace std;



const int IINF = INT_MAX;



int H,W,mini,field[10][10],prev[10][10],mindist[10][10],nfield[10][10],mindist2[10][10],m1[10][10],m2[10][10];

vector<int> sp[2];

bool visited[10][10];

int dx[] = {0,1,0,-1};

int dy[] = {1,0,-1,0};

bool X[10], Y[10];



bool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }



void simulate_min(int dist[10][10],int f[10][10],int s){

  rep(i,H) rep(j,W) dist[i][j] = IINF;

  dist[s/W][s%W] = 0;

  deque<int> deq;

  deq.push_back(s);

  while( !deq.empty() ){

    int cur = deq.front(); deq.pop_front();

    int x = cur % W, y = cur / W;

    rep(i,4){

      int nx = x + dx[i], ny = y + dy[i];

      if( !isValid(nx,ny) ) continue;

      if( f[ny][nx] != 0 && f[ny][nx] != f[s/W][s%W] ) continue;

      if( dist[ny][nx] == IINF ) {

        dist[ny][nx] = dist[y][x] + 1;

        deq.push_back(nx+ny*W);

      }

    }

  }

}





void dfs(int x,int y,int cost,int f[10][10],int ep,deque<int> &path,int F,int S,int prev){



  if( cost >= mini ) return;

  if( m2[sp[S][1]/W][sp[S][1]%W] + cost >= mini ) return;











  if( x + y * W == ep ) {

    rep(i,H) rep(j,W) nfield[i][j] = field[i][j];

    rep(i,path.size()) nfield[path[i]/W][path[i]%W] = 1;

    simulate_min(mindist2,nfield,sp[S][0]);

    if( mindist2[sp[S][1]/W][sp[S][1]%W] == IINF ) return;

    mini = min(mini,(int)path.size()-1+mindist2[sp[S][1]/W][sp[S][1]%W]);

    return;

  }

  int cnt = 0;

  rep(i,4) {

    int nx = x + dx[i], ny = y + dy[i];

    if( !isValid(nx,ny) ) continue;

    cnt += visited[ny][nx];

 }

  if( cnt >= 2 ) return;





  {

    rep(i,4){

      int nx = x, ny = y;

      nx += dx[i], ny += dy[i];

      if( !isValid(nx,ny) ) continue;

      if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) continue;

      if( visited[ny][nx] ) continue;

      while(1){

        nx += dx[i], ny += dy[i];

        if( !isValid(nx,ny) ) break;

        if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) break;

        if( X[nx] || Y[ny] ) break;

        if( visited[ny][nx] ) return;

      }

    }

  }





  rep(i,4) {

    if( i == (prev+2) % 4 ) continue;

    int nx = x + dx[i], ny = y + dy[i];

    if( !isValid(nx,ny) ) continue;

    if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) continue;

    if( visited[ny][nx] ) continue;

    visited[ny][nx] = true;

    path.push_back(nx+ny*W);

    dfs(nx,ny,cost+1,f,ep,path,F,S,i);

    path.pop_back();

    visited[ny][nx] = false;

  }





}



int compute(int F,int S){

  rep(i,H) rep(j,W) visited[i][j] = false;

  deque<int> path;

  path.push_back(sp[F][0]);

  visited[sp[F][0]/W][sp[F][0]%W] = true;

  simulate_min(m1,field,sp[F][0]);

  simulate_min(m2,field,sp[S][0]);

  dfs(sp[F][0]%W,sp[F][0]/W,0,field,sp[F][1],path,F,S,-IINF);

}



int main(){

  while( cin >> H >> W, H|W ){

    rep(i,2) sp[i].clear();

    rep(i,10) X[i] = Y[i] = false;

    rep(i,H) rep(j,W) {

      cin >> field[i][j];

      if( field[i][j] == 1 ) X[j] = true, Y[i] = true;

      if( field[i][j] == 2 ) sp[0].push_back(j+i*W), X[j] = Y[i] = true;

      if( field[i][j] == 3 ) sp[1].push_back(j+i*W), X[j] = Y[i] = true;

    }

    mini = IINF;



    compute(0,1);

    if( mini == IINF ) puts(""0"");

    else cout << mini << endl;

  }

  return 0;

}",5.08,127.0,125.0,C++,cpp
u116766943,p00849,C++,s829771916,8780.0,1228.0,Time Limit Exceeded,"#include<bits/stdc++.h>



#define REP(i,s,n) for(int i=s;i<n;i++)

#define rep(i,n) REP(i,0,n)



using namespace std;



const int IINF = INT_MAX;



int H,W,mini,field[10][10],prev[10][10],mindist[10][10],nfield[10][10],mindist2[10][10],m1[10][10],m2[10][10];

vector<int> sp[2];

bool visited[10][10];

int dx[] = {0,1,0,-1};

int dy[] = {1,0,-1,0};

bool X[10], Y[10];



bool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }



void simulate_min(int dist[10][10],int f[10][10],int s){

  rep(i,H) rep(j,W) dist[i][j] = IINF;

  dist[s/W][s%W] = 0;

  deque<int> deq;

  deq.push_back(s);

  while( !deq.empty() ){

    int cur = deq.front(); deq.pop_front();

    int x = cur % W, y = cur / W;

    if( x+y*W != s && f[y][x] == f[s/W][s%W] ) return;

    rep(i,4){

      int nx = x + dx[i], ny = y + dy[i];

      if( !isValid(nx,ny) ) continue;

      if( f[ny][nx] != 0 && f[ny][nx] != f[s/W][s%W] ) continue;

      if( dist[ny][nx] == IINF ) {

        dist[ny][nx] = dist[y][x] + 1;

        deq.push_back(nx+ny*W);

      }

    }

  }

}





void dfs(int x,int y,int cost,int f[10][10],int ep,deque<int> &path,int F,int S,int prev){



  if( cost >= mini ) return;

  if( m1[ep/W][ep%W] - m1[y][x] + m2[sp[S][1]/W][sp[S][1]%W] + cost >= mini ) return;





  if( x + y * W == ep ) {

    rep(i,H) rep(j,W) nfield[i][j] = field[i][j];

    rep(i,path.size()) nfield[path[i]/W][path[i]%W] = 1;

    simulate_min(mindist2,nfield,sp[S][0]);

    if( mindist2[sp[S][1]/W][sp[S][1]%W] == IINF ) return;

    mini = min(mini,(int)path.size()-1+mindist2[sp[S][1]/W][sp[S][1]%W]);

    return;

  }

  int cnt = 0;

  rep(i,4) {

    int nx = x + dx[i], ny = y + dy[i];

    if( !isValid(nx,ny) ) continue;

    cnt += visited[ny][nx];

 }

  if( cnt >= 2 ) return;





  {

    rep(i,4){

      int nx = x, ny = y;

      nx += dx[i], ny += dy[i];

      if( !isValid(nx,ny) ) continue;

      if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) continue;

      if( visited[ny][nx] ) continue;

      while(1){

        nx += dx[i], ny += dy[i];

        if( !isValid(nx,ny) ) break;

        if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) break;

        if( X[nx] || Y[ny] ) break;

        if( visited[ny][nx] ) return;

      }

    }

  }





  rep(i,4) {

    if( i == (prev+2) % 4 ) continue;

    int nx = x + dx[i], ny = y + dy[i];

    if( !isValid(nx,ny) ) continue;

    if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) continue;

    if( visited[ny][nx] ) continue;

    visited[ny][nx] = true;

    path.push_back(nx+ny*W);

    dfs(nx,ny,cost+1,f,ep,path,F,S,i);

    path.pop_back();

    visited[ny][nx] = false;

  }





}



int compute(int F,int S){

  rep(i,H) rep(j,W) visited[i][j] = false;

  deque<int> path;

  path.push_back(sp[F][0]);

  visited[sp[F][0]/W][sp[F][0]%W] = true;

  simulate_min(m1,field,sp[F][0]);

  simulate_min(m2,field,sp[S][0]);

  dfs(sp[F][0]%W,sp[F][0]/W,0,field,sp[F][1],path,F,S,-IINF);

}



int main(){

  while( cin >> H >> W, H|W ){

    rep(i,2) sp[i].clear();

    rep(i,10) X[i] = Y[i] = false;

    rep(i,H) rep(j,W) {

      cin >> field[i][j];

      if( field[i][j] == 1 ) X[j] = true, Y[i] = true;

      if( field[i][j] == 2 ) sp[0].push_back(j+i*W), X[j] = Y[i] = true;

      if( field[i][j] == 3 ) sp[1].push_back(j+i*W), X[j] = Y[i] = true;

    }

    mini = IINF;



    compute(0,1);

    if( mini == IINF ) puts(""0"");

    else cout << mini << endl;

  }

  return 0;

}",5.08,127.0,125.0,C++,cpp
u116766943,p00849,C++,s812631681,8700.0,1232.0,Time Limit Exceeded,"#include<bits/stdc++.h>



#define REP(i,s,n) for(int i=s;i<n;i++)

#define rep(i,n) REP(i,0,n)



using namespace std;



const int IINF = INT_MAX;



int H,W,mini,field[10][10],prev[10][10],mindist[10][10],nfield[10][10],mindist2[10][10],m1[10][10],m2[10][10];

vector<int> sp[2];

bool visited[10][10];

int dx[] = {0,1,0,-1};

int dy[] = {1,0,-1,0};

bool X[10], Y[10];



bool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }



void simulate_min(int dist[10][10],int f[10][10],int s){

  rep(i,H) rep(j,W) dist[i][j] = IINF;

  dist[s/W][s%W] = 0;

  deque<int> deq;

  deq.push_back(s);

  while( !deq.empty() ){

    int cur = deq.front(); deq.pop_front();

    int x = cur % W, y = cur / W;

    if( x+y*W != s && f[y][x] == f[s/W][s%W] ) return;

    rep(i,4){

      int nx = x + dx[i], ny = y + dy[i];

      if( !isValid(nx,ny) ) continue;

      if( f[ny][nx] != 0 && f[ny][nx] != f[s/W][s%W] ) continue;

      if( dist[ny][nx] == IINF ) {

        dist[ny][nx] = dist[y][x] + 1;

        deq.push_back(nx+ny*W);

      }

    }

  }

}





void dfs(int x,int y,int cost,int f[10][10],int ep,deque<int> &path,int F,int S,int prev){



  if( cost >= mini ) return;

  if( m1[ep/W][ep%W] - m1[y][x] + m2[sp[S][1]/W][sp[S][1]%W] + cost >= mini ) return;





  if( x + y * W == ep ) {

    rep(i,H) rep(j,W) nfield[i][j] = field[i][j];

    rep(i,path.size()) nfield[path[i]/W][path[i]%W] = 1;

    simulate_min(mindist2,nfield,sp[S][0]);

    if( mindist2[sp[S][1]/W][sp[S][1]%W] == IINF ) return;

    mini = min(mini,(int)path.size()-1+mindist2[sp[S][1]/W][sp[S][1]%W]);

    return;

  }

  int cnt = 0;

  rep(i,4) {

    int nx = x + dx[i], ny = y + dy[i];

    if( !isValid(nx,ny) ) continue;

    cnt += visited[ny][nx];

 }

  if( cnt >= 2 ) return;





  {

    rep(i,4){

      if( i == (prev+2) % 4 ) continue;

      int nx = x, ny = y;

      nx += dx[i], ny += dy[i];

      if( !isValid(nx,ny) ) continue;

      if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) continue;

      if( visited[ny][nx] ) continue;

      while(1){

        nx += dx[i], ny += dy[i];

        if( !isValid(nx,ny) ) break;

        if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) break;

        if( X[nx] || Y[ny] ) break;

        if( visited[ny][nx] ) return;

      }

    }

  }





  rep(i,4) {

    if( i == (prev+2) % 4 ) continue;

    int nx = x + dx[i], ny = y + dy[i];

    if( !isValid(nx,ny) ) continue;

    if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) continue;

    if( visited[ny][nx] ) continue;

    visited[ny][nx] = true;

    path.push_back(nx+ny*W);

    dfs(nx,ny,cost+1,f,ep,path,F,S,i);

    path.pop_back();

    visited[ny][nx] = false;

  }





}



int compute(int F,int S){

  rep(i,H) rep(j,W) visited[i][j] = false;

  deque<int> path;

  path.push_back(sp[F][0]);

  visited[sp[F][0]/W][sp[F][0]%W] = true;

  simulate_min(m1,field,sp[F][0]);

  simulate_min(m2,field,sp[S][0]);

  dfs(sp[F][0]%W,sp[F][0]/W,0,field,sp[F][1],path,F,S,-IINF);

}



bool check(int a){

  int x = a % W, y = a / W;

  return 0 == x || W-1 == x || 0 == y || H-1 == y;

}



int main(){

  while( cin >> H >> W, H|W ){

    rep(i,2) sp[i].clear();

    rep(i,10) X[i] = Y[i] = false;

    rep(i,H) rep(j,W) {

      cin >> field[i][j];

      if( field[i][j] == 1 ) X[j] = true, Y[i] = true;

      if( field[i][j] == 2 ) sp[0].push_back(j+i*W), X[j] = Y[i] = true;

      if( field[i][j] == 3 ) sp[1].push_back(j+i*W), X[j] = Y[i] = true;

    }

    mini = IINF;

    if( check(sp[0][1]) && check(sp[0][0]) && check(sp[1][1]) && check(sp[1][0]) ) {

      vector<int> vec;

      for(int i=0;i<W;i++) if( field[0][i] == 2 || field[0][i] == 3 ) vec.push_back(field[0][i]);

      for(int i=1;i<H;i++) if( field[i][W-1] == 2 || field[i][W-1] == 3 ) vec.push_back(field[i][W-1]);

      for(int i=W-2;i>=0;i--) if( field[H-1][i] == 2 || field[H-1][i] == 3 ) vec.push_back(field[H-1][i]);

      for(int i=H-2;i>=1;i--) if( field[i][0] == 2 || field[i][0] == 3 ) vec.push_back(field[i][0]);

      assert(vec.size() == 4);

      if( !( vec[0] == vec[1] || vec[0] == vec[3] ) ) {

        puts(""0"");

        continue;

      }

    }





    compute(0,1);

    if( mini == IINF ) puts(""0"");

    else cout << mini << endl;

  }

  return 0;

}",7.7,144.0,144.0,C++,cpp
u116766943,p00849,C++,s154463767,8030.0,1232.0,Time Limit Exceeded,"#include<bits/stdc++.h>



#define REP(i,s,n) for(int i=s;i<n;i++)

#define rep(i,n) REP(i,0,n)



using namespace std;



const int IINF = INT_MAX;



int H,W,mini,field[10][10],prev[10][10],mindist[10][10],nfield[10][10],mindist2[10][10],m1[10][10],m2[10][10];

vector<int> sp[2];

bool visited[10][10];

int dx[] = {0,1,0,-1};

int dy[] = {1,0,-1,0};

bool X[10], Y[10];



bool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }



void simulate_min(int dist[10][10],int f[10][10],int s){

  rep(i,H) rep(j,W) dist[i][j] = IINF;

  dist[s/W][s%W] = 0;

  deque<int> deq;

  deq.push_back(s);

  while( !deq.empty() ){

    int cur = deq.front(); deq.pop_front();

    int x = cur % W, y = cur / W;

    if( x+y*W != s && f[y][x] == f[s/W][s%W] ) return;

    rep(i,4){

      int nx = x + dx[i], ny = y + dy[i];

      if( !isValid(nx,ny) ) continue;

      if( f[ny][nx] != 0 && f[ny][nx] != f[s/W][s%W] ) continue;

      if( dist[ny][nx] == IINF ) {

        dist[ny][nx] = dist[y][x] + 1;

        deq.push_back(nx+ny*W);

      }

    }

  }

}





void dfs(int x,int y,int cost,int f[10][10],int ep,deque<int> &path,int F,int S,int prev){



  if( cost >= mini ) return;

  if( m1[ep/W][ep%W] - m1[y][x] + m2[sp[S][1]/W][sp[S][1]%W] + cost >= mini ) return;





  if( x + y * W == ep ) {

    rep(i,H) rep(j,W) nfield[i][j] = field[i][j];

    rep(i,path.size()) nfield[path[i]/W][path[i]%W] = 1;

    simulate_min(mindist2,nfield,sp[S][0]);

    if( mindist2[sp[S][1]/W][sp[S][1]%W] == IINF ) return;

    mini = min(mini,(int)path.size()-1+mindist2[sp[S][1]/W][sp[S][1]%W]);

    return;

  }

  int cnt = 0;

  rep(i,4) {

    int nx = x + dx[i], ny = y + dy[i];

    if( !isValid(nx,ny) ) continue;

    cnt += visited[ny][nx];

 }

  if( cnt >= 2 ) return;





  {

    rep(i,4){

      if( i == (prev+2) % 4 ) continue;

      int nx = x, ny = y;

      nx += dx[i], ny += dy[i];

      if( !isValid(nx,ny) ) continue;

      if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) continue;

      if( visited[ny][nx] ) continue;

      while(1){

        nx += dx[i], ny += dy[i];

        if( !isValid(nx,ny) ) break;

        if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) break;

        if( X[nx] || Y[ny] ) break;

        if( visited[ny][nx] ) return;

      }

    }

  }





  rep(i,4) {

    if( i == (prev+2) % 4 ) continue;

    int nx = x + dx[i], ny = y + dy[i];

    if( !isValid(nx,ny) ) continue;

    if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) continue;

    if( visited[ny][nx] ) continue;

    visited[ny][nx] = true;

    path.push_back(nx+ny*W);

    dfs(nx,ny,cost+1,f,ep,path,F,S,i);

    path.pop_back();

    visited[ny][nx] = false;

  }





}



int compute(int F,int S){

  rep(i,H) rep(j,W) visited[i][j] = false;

  deque<int> path;

  path.push_back(sp[F][0]);

  visited[sp[F][0]/W][sp[F][0]%W] = true;

  simulate_min(m1,field,sp[F][0]);

  simulate_min(m2,field,sp[S][0]);

  dfs(sp[F][0]%W,sp[F][0]/W,0,field,sp[F][1],path,F,S,-IINF);

}



bool check(int a){

  int x = a % W, y = a / W;

  return 0 == x || W-1 == x || 0 == y || H-1 == y;

}



int main(){

  while( cin >> H >> W, H|W ){

    rep(i,2) sp[i].clear();

    rep(i,10) X[i] = Y[i] = false;

    rep(i,H) rep(j,W) {

      cin >> field[i][j];

      if( field[i][j] == 1 ) X[j] = true, Y[i] = true;

      if( field[i][j] == 2 ) sp[0].push_back(j+i*W), X[j] = Y[i] = true;

      if( field[i][j] == 3 ) sp[1].push_back(j+i*W), X[j] = Y[i] = true;

    }

    mini = IINF;

    if( check(sp[0][1]) && check(sp[0][0]) && check(sp[1][1]) && check(sp[1][0]) ) {

      vector<int> vec;

      for(int i=0;i<W;i++) if( field[0][i] == 2 || field[0][i] == 3 ) vec.push_back(field[0][i]);

      for(int i=1;i<H;i++) if( field[i][W-1] == 2 || field[i][W-1] == 3 ) vec.push_back(field[i][W-1]);

      for(int i=W-2;i>=0;i--) if( field[H-1][i] == 2 || field[H-1][i] == 3 ) vec.push_back(field[H-1][i]);

      for(int i=H-2;i>=1;i--) if( field[i][0] == 2 || field[i][0] == 3 ) vec.push_back(field[i][0]);

      assert(vec.size() == 4);

      if( !( vec[0] == vec[1] || vec[0] == vec[3] ) ) {

        puts(""0"");

        continue;

      }

    }





    compute(0,1);

    if( mini == IINF ) puts(""0"");

    else cout << mini << endl;

  }

  return 0;

}",7.7,144.0,144.0,C++11,cpp
u116766943,p00849,C++,s363969251,8500.0,1252.0,Time Limit Exceeded,"#include<bits/stdc++.h>



#define REP(i,s,n) for(int i=s;i<n;i++)

#define rep(i,n) REP(i,0,n)



using namespace std;



const int IINF = INT_MAX;



int H,W,mini,field[10][10],prev[10][10],mindist[10][10],nfield[10][10],mindist2[10][10],m1[10][10],m2[10][10];

vector<int> sp[2];

bool visited[10][10];

int dx[] = {0,1,0,-1};

int dy[] = {1,0,-1,0};

bool X[10], Y[10];



bool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }



void simulate_min(int dist[10][10],int f[10][10],int s){

  rep(i,H) rep(j,W) dist[i][j] = IINF;

  dist[s/W][s%W] = 0;

  deque<int> deq;

  deq.push_back(s);

  while( !deq.empty() ){

    int cur = deq.front(); deq.pop_front();

    int x = cur % W, y = cur / W;

    if( x+y*W != s && f[y][x] == f[s/W][s%W] ) return;

    rep(i,4){

      int nx = x + dx[i], ny = y + dy[i];

      if( !isValid(nx,ny) ) continue;

      if( f[ny][nx] != 0 && f[ny][nx] != f[s/W][s%W] ) continue;

      if( dist[ny][nx] == IINF ) {

        dist[ny][nx] = dist[y][x] + 1;

        deq.push_back(nx+ny*W);

      }

    }

  }

}





void dfs(int x,int y,int cost,int f[10][10],int ep,deque<int> &path,int F,int S,int prev){



  if( cost >= mini ) return;

  if( m2[sp[S][1]/W][sp[S][1]%W] + cost >= mini ) return;





  if( x + y * W == ep ) {

    rep(i,H) rep(j,W) nfield[i][j] = field[i][j];

    rep(i,path.size()) nfield[path[i]/W][path[i]%W] = 1;

    simulate_min(mindist2,nfield,sp[S][0]);

    if( mindist2[sp[S][1]/W][sp[S][1]%W] == IINF ) return;

    mini = min(mini,(int)path.size()-1+mindist2[sp[S][1]/W][sp[S][1]%W]);

    return;

  }

  int cnt = 0;

  rep(i,4) {

    int nx = x + dx[i], ny = y + dy[i];

    if( !isValid(nx,ny) ) continue;

    cnt += visited[ny][nx];

 }

  if( cnt >= 2 ) return;





  {

    rep(i,4){

      if( i == (prev+2) % 4 ) continue;

      int nx = x, ny = y;

      nx += dx[i], ny += dy[i];

      if( !isValid(nx,ny) ) continue;

      if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) continue;

      if( visited[ny][nx] ) continue;

      while(1){

        nx += dx[i], ny += dy[i];

        if( !isValid(nx,ny) ) break;

        if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) break;

        if( X[nx] || Y[ny] ) break;

        if( visited[ny][nx] ) return;

      }

    }

  }





  rep(i,4) {

    if( i == (prev+2) % 4 ) continue;

    int nx = x + dx[i], ny = y + dy[i];

    if( !isValid(nx,ny) ) continue;

    if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) continue;

    if( visited[ny][nx] ) continue;

    visited[ny][nx] = true;

    path.push_back(nx+ny*W);

    dfs(nx,ny,cost+1,f,ep,path,F,S,i);

    path.pop_back();

    visited[ny][nx] = false;

  }





}



int compute(int F,int S){

  rep(i,H) rep(j,W) visited[i][j] = false;

  deque<int> path;

  path.push_back(sp[F][0]);

  visited[sp[F][0]/W][sp[F][0]%W] = true;

  simulate_min(m1,field,sp[F][0]);

  simulate_min(m2,field,sp[S][0]);

  dfs(sp[F][0]%W,sp[F][0]/W,0,field,sp[F][1],path,F,S,-IINF);

}



bool check(int a){

  int x = a % W, y = a / W;

  return 0 == x || W-1 == x || 0 == y || H-1 == y;

}



int main(){

  while( scanf(""%d %d"",&H,&W), H|W ){

    rep(i,2) sp[i].clear();

    rep(i,10) X[i] = Y[i] = false;

    int one = 0;

    rep(i,H) rep(j,W) {

      cin >> field[i][j];

      if( field[i][j] == 1 ) X[j] = true, Y[i] = true, one++;

      if( field[i][j] == 2 ) sp[0].push_back(j+i*W), X[j] = Y[i] = true;

      if( field[i][j] == 3 ) sp[1].push_back(j+i*W), X[j] = Y[i] = true;

    }

    mini = H*W - one;

    if( check(sp[0][1]) && check(sp[0][0]) && check(sp[1][1]) && check(sp[1][0]) ) {

      vector<int> vec;

      for(int i=0;i<W;i++) if( field[0][i] == 2 || field[0][i] == 3 ) vec.push_back(field[0][i]);

      for(int i=1;i<H;i++) if( field[i][W-1] == 2 || field[i][W-1] == 3 ) vec.push_back(field[i][W-1]);

      for(int i=W-2;i>=0;i--) if( field[H-1][i] == 2 || field[H-1][i] == 3 ) vec.push_back(field[H-1][i]);

      for(int i=H-2;i>=1;i--) if( field[i][0] == 2 || field[i][0] == 3 ) vec.push_back(field[i][0]);

      assert(vec.size() == 4);

      if( !( vec[0] == vec[1] || vec[0] == vec[3] ) ) {

        puts(""0"");

        continue;

      }

    }





    compute(0,1);

    if( mini == IINF ) puts(""0"");

    else printf(""%d\n"",mini);

  }

  return 0;

}",89.18,145.0,214.0,C++11,cpp
u116766943,p00849,C++,s061168313,920.0,12164.0,Accepted,"#include<bits/stdc++.h>



#define REP(i,s,n) for(int i=s;i<n;i++)

#define rep(i,n) REP(i,0,n)



using namespace std;



const int IINF = INT_MAX;

const int MAX_W = 9;

typedef pair<int,int> ii;





int h,w;

int field[10][10],indice[10][10];

int dp[2][1<<((MAX_W+1)*2)];

int dx[] = {1,0,-1,0};

int dy[] = {0,1,0,-1};



inline bool isValid(int x,int y) { return 0 <= x && x < w && 0 <= y && y < h; }



#define SET(bitmask,index,value) ( bitmask = ( ( bitmask & ~(1<<(2*index)) & ~(1<<(2*index+1)) ) | ( value << (index*2) ) ) )

#define GET(bitmask,x) ( ( ( bitmask >> ( 2 * x ) ) & 1 ) | ( ( ( bitmask >> (2*x+1) ) & 1) << 1 ) )

#define FIX(bitmask) ((bitmask<<2)&((1<<(2*(w+1)))-1))

#define STAR ( field[y][x] == 2 || field[y][x] == 3 )

#define update(x,v) ( ( x == -1 ) ? ( x = v ) : ( x = min(x,v) ) )





void compute(){



  set<int> S;

  vector<int> state;

  rep(bitmask,(1<<((w+1)*2))) {

    bool success = true;

    for(int i=0;i<(w+1)*2;i+=2){

      if( ( ( bitmask >> i ) & 1 ) && ( ( bitmask >> (i+1) ) & 1 ) ) { success = false; break; }

    }

    if( success ) state.push_back(bitmask), S.insert(bitmask);

  }

  memset(dp,-1,sizeof(dp));



  int _size = state.size();

  bool initter = true, phase = false;

  int mini = IINF;

  int encounter = 0;

  rep(y,h){

    rep(x,w){

      /*

      cout << x << "","" << y << endl;

      rep(i,_size){

        if( dp[phase][state[i]] != -1 ) {

          bitset<12> BIT(state[i]);

          for(int j=0;j<12;j+=2){

            cout << BIT[j] << BIT[j+1] << "" "";

          } 

          cout << "" = "" << dp[phase][state[i]] << endl;

        }

      }

      */

      if( field[y][x] == 2 || field[y][x] == 3 ) ++encounter;

      if( initter ) dp[phase][0] = 0;



      rep(i,_size){

        int bitmask = state[i];



        if( dp[phase][bitmask] == -1 ) continue;

        bitset<12> bit(bitmask);





        assert( S.count(bitmask));

        // ?????????

        if( field[y][x] == 1 ) {

          int nbitmask = bitmask;

          SET(nbitmask,x,0);

          if( x == w-1 ) nbitmask = FIX(nbitmask);

          update(dp[!phase][nbitmask],dp[phase][bitmask]);

          continue;

        }



        int nbitmask;

        // 0 0

        if( !( ( GET(bitmask,x) == 0 ) && ( GET(bitmask,(x+1)) == 0 ) ) ) goto Label1;

        if( STAR ) {

          // x 0

          if( y+1 < h && field[y+1][x] != 1 ) {

            nbitmask = bitmask;

            SET(nbitmask,x,((field[y][x]==3)+1));

          if( x == w-1 ) nbitmask = FIX(nbitmask);



            update(dp[!phase][nbitmask],dp[phase][bitmask]+1);

          }

          // 0 x

          if( x+1 < w && field[y][x+1] != 1 ) {

            nbitmask = bitmask;

            SET(nbitmask,(x+1),((field[y][x]==3)+1));



          if( x == w-1 ) nbitmask = FIX(nbitmask);



          update(dp[!phase][nbitmask],dp[phase][bitmask]+1);

          }

        } else {

          // x x

          if( x+1 < w && y+1 < h && field[y][x+1] != 1 && field[y+1][x] != 1 ) {

            REP(color,1,3){

              nbitmask = bitmask;

              SET(nbitmask,x,color);

              SET(nbitmask,(x+1),color);

              if( x == w-1 ) nbitmask = FIX(nbitmask);

              update(dp[!phase][nbitmask],(dp[phase][bitmask]+1));

            }

          }

          // 0 0

          nbitmask = bitmask;

          SET(nbitmask,x,0);

          SET(nbitmask,(x+1),0);

          if( x == w-1 ) nbitmask = FIX(nbitmask);

          update(dp[!phase][nbitmask],dp[phase][bitmask]);

        }



        continue;

      Label1:;

        // x 0

        // 0 x

        int color;

        if( !( ( GET(bitmask,x) && ( GET(bitmask,(x+1)) == 0 ) ) || ( GET(bitmask,(x+1)) && ( GET(bitmask,x) == 0 ) ) ) ) goto Label2;

        color = GET(bitmask,x) | GET(bitmask,(x+1));

        assert( color == 1 || color == 2 );

        if( STAR ) {

          // 0 0

          if( ((color==1)?2:3) == field[y][x] ) {



            nbitmask = bitmask;

            SET(nbitmask,x,0);

            SET(nbitmask,(x+1),0);

          if( x == w-1 ) nbitmask = FIX(nbitmask);

            update(dp[!phase][nbitmask],dp[phase][bitmask]+1);

          }

        } else {

          // x 0

          if( y+1 < h && field[y+1][x] != 1 ) {

            nbitmask = bitmask;

            SET(nbitmask,x,color);

            SET(nbitmask,(x+1),0);

          if( x == w-1 ) nbitmask = FIX(nbitmask);





            update(dp[!phase][nbitmask],(dp[phase][bitmask]+1));

          }

          

          // 0 x

          if( x+1 < w && field[y][x+1] != 1 ) {

            nbitmask = bitmask;

            SET(nbitmask,x,0);

            SET(nbitmask,(x+1),color);



          if( x == w-1 ) nbitmask = FIX(nbitmask);

            update(dp[!phase][nbitmask],(dp[phase][bitmask]+1));

          }

        }

        continue;

      Label2:;

        // x x

        if( !( GET(bitmask,x) && GET(bitmask,(x+1)) ) ) goto Label3;

        if( GET(bitmask,x) != GET(bitmask,(x+1)) ) goto Label3;



        color = GET(bitmask,x);

        assert( color );

        //assert( GET(bitmask,x) == GET(bitmask,(x+1)) );

        

        // 0 0

        if( !STAR ) {

          nbitmask = bitmask;

          SET(nbitmask,x,0);

          SET(nbitmask,(x+1),0);

          if( x == w-1 ) nbitmask = FIX(nbitmask);

          update(dp[!phase][nbitmask],dp[phase][bitmask]+1);

        }

      Label3:;



      }

      if( field[y][x] == 2 || field[y][x] == 3 ) initter = false;

      rep(i,_size) dp[phase][state[i]] = -1;

      if( encounter >= 4 && dp[!phase][0] != -1 ) {

        mini = min(mini,dp[!phase][0]);

      }

      phase = !phase;

    }

  }



  /*

  puts(""final"");

  rep(i,_size){

    if( dp[phase][state[i]] != -1 ) {

      bitset<12> BIT(state[i]);

      for(int j=0;j<12;j+=2){

        cout << BIT[j] << BIT[j+1] << "" "";

      } 

      cout << "" = "" << dp[phase][state[i]] << endl;

    }

  }

  */

  if( dp[phase][0] != -1 ) mini = min(mini,dp[phase][0]);

  if( mini != IINF ) printf(""%d\n"",mini-2);

  else puts(""0"");

}



int main(){





  while( scanf(""%d %d"",&h,&w), h|w ){

    rep(i,h) rep(j,w) scanf(""%d"",&field[i][j]);

    compute();

  }

  return 0;

}",89.18,145.0,214.0,C++,cpp
u116766943,p00849,C++,s061168313,920.0,12164.0,Accepted,"#include<bits/stdc++.h>



#define REP(i,s,n) for(int i=s;i<n;i++)

#define rep(i,n) REP(i,0,n)



using namespace std;



const int IINF = INT_MAX;

const int MAX_W = 9;

typedef pair<int,int> ii;





int h,w;

int field[10][10],indice[10][10];

int dp[2][1<<((MAX_W+1)*2)];

int dx[] = {1,0,-1,0};

int dy[] = {0,1,0,-1};



inline bool isValid(int x,int y) { return 0 <= x && x < w && 0 <= y && y < h; }



#define SET(bitmask,index,value) ( bitmask = ( ( bitmask & ~(1<<(2*index)) & ~(1<<(2*index+1)) ) | ( value << (index*2) ) ) )

#define GET(bitmask,x) ( ( ( bitmask >> ( 2 * x ) ) & 1 ) | ( ( ( bitmask >> (2*x+1) ) & 1) << 1 ) )

#define FIX(bitmask) ((bitmask<<2)&((1<<(2*(w+1)))-1))

#define STAR ( field[y][x] == 2 || field[y][x] == 3 )

#define update(x,v) ( ( x == -1 ) ? ( x = v ) : ( x = min(x,v) ) )





void compute(){



  set<int> S;

  vector<int> state;

  rep(bitmask,(1<<((w+1)*2))) {

    bool success = true;

    for(int i=0;i<(w+1)*2;i+=2){

      if( ( ( bitmask >> i ) & 1 ) && ( ( bitmask >> (i+1) ) & 1 ) ) { success = false; break; }

    }

    if( success ) state.push_back(bitmask), S.insert(bitmask);

  }

  memset(dp,-1,sizeof(dp));



  int _size = state.size();

  bool initter = true, phase = false;

  int mini = IINF;

  int encounter = 0;

  rep(y,h){

    rep(x,w){

      /*

      cout << x << "","" << y << endl;

      rep(i,_size){

        if( dp[phase][state[i]] != -1 ) {

          bitset<12> BIT(state[i]);

          for(int j=0;j<12;j+=2){

            cout << BIT[j] << BIT[j+1] << "" "";

          } 

          cout << "" = "" << dp[phase][state[i]] << endl;

        }

      }

      */

      if( field[y][x] == 2 || field[y][x] == 3 ) ++encounter;

      if( initter ) dp[phase][0] = 0;



      rep(i,_size){

        int bitmask = state[i];



        if( dp[phase][bitmask] == -1 ) continue;

        bitset<12> bit(bitmask);





        assert( S.count(bitmask));

        // ?????????

        if( field[y][x] == 1 ) {

          int nbitmask = bitmask;

          SET(nbitmask,x,0);

          if( x == w-1 ) nbitmask = FIX(nbitmask);

          update(dp[!phase][nbitmask],dp[phase][bitmask]);

          continue;

        }



        int nbitmask;

        // 0 0

        if( !( ( GET(bitmask,x) == 0 ) && ( GET(bitmask,(x+1)) == 0 ) ) ) goto Label1;

        if( STAR ) {

          // x 0

          if( y+1 < h && field[y+1][x] != 1 ) {

            nbitmask = bitmask;

            SET(nbitmask,x,((field[y][x]==3)+1));

          if( x == w-1 ) nbitmask = FIX(nbitmask);



            update(dp[!phase][nbitmask],dp[phase][bitmask]+1);

          }

          // 0 x

          if( x+1 < w && field[y][x+1] != 1 ) {

            nbitmask = bitmask;

            SET(nbitmask,(x+1),((field[y][x]==3)+1));



          if( x == w-1 ) nbitmask = FIX(nbitmask);



          update(dp[!phase][nbitmask],dp[phase][bitmask]+1);

          }

        } else {

          // x x

          if( x+1 < w && y+1 < h && field[y][x+1] != 1 && field[y+1][x] != 1 ) {

            REP(color,1,3){

              nbitmask = bitmask;

              SET(nbitmask,x,color);

              SET(nbitmask,(x+1),color);

              if( x == w-1 ) nbitmask = FIX(nbitmask);

              update(dp[!phase][nbitmask],(dp[phase][bitmask]+1));

            }

          }

          // 0 0

          nbitmask = bitmask;

          SET(nbitmask,x,0);

          SET(nbitmask,(x+1),0);

          if( x == w-1 ) nbitmask = FIX(nbitmask);

          update(dp[!phase][nbitmask],dp[phase][bitmask]);

        }



        continue;

      Label1:;

        // x 0

        // 0 x

        int color;

        if( !( ( GET(bitmask,x) && ( GET(bitmask,(x+1)) == 0 ) ) || ( GET(bitmask,(x+1)) && ( GET(bitmask,x) == 0 ) ) ) ) goto Label2;

        color = GET(bitmask,x) | GET(bitmask,(x+1));

        assert( color == 1 || color == 2 );

        if( STAR ) {

          // 0 0

          if( ((color==1)?2:3) == field[y][x] ) {



            nbitmask = bitmask;

            SET(nbitmask,x,0);

            SET(nbitmask,(x+1),0);

          if( x == w-1 ) nbitmask = FIX(nbitmask);

            update(dp[!phase][nbitmask],dp[phase][bitmask]+1);

          }

        } else {

          // x 0

          if( y+1 < h && field[y+1][x] != 1 ) {

            nbitmask = bitmask;

            SET(nbitmask,x,color);

            SET(nbitmask,(x+1),0);

          if( x == w-1 ) nbitmask = FIX(nbitmask);





            update(dp[!phase][nbitmask],(dp[phase][bitmask]+1));

          }

          

          // 0 x

          if( x+1 < w && field[y][x+1] != 1 ) {

            nbitmask = bitmask;

            SET(nbitmask,x,0);

            SET(nbitmask,(x+1),color);



          if( x == w-1 ) nbitmask = FIX(nbitmask);

            update(dp[!phase][nbitmask],(dp[phase][bitmask]+1));

          }

        }

        continue;

      Label2:;

        // x x

        if( !( GET(bitmask,x) && GET(bitmask,(x+1)) ) ) goto Label3;

        if( GET(bitmask,x) != GET(bitmask,(x+1)) ) goto Label3;



        color = GET(bitmask,x);

        assert( color );

        //assert( GET(bitmask,x) == GET(bitmask,(x+1)) );

        

        // 0 0

        if( !STAR ) {

          nbitmask = bitmask;

          SET(nbitmask,x,0);

          SET(nbitmask,(x+1),0);

          if( x == w-1 ) nbitmask = FIX(nbitmask);

          update(dp[!phase][nbitmask],dp[phase][bitmask]+1);

        }

      Label3:;



      }

      if( field[y][x] == 2 || field[y][x] == 3 ) initter = false;

      rep(i,_size) dp[phase][state[i]] = -1;

      if( encounter >= 4 && dp[!phase][0] != -1 ) {

        mini = min(mini,dp[!phase][0]);

      }

      phase = !phase;

    }

  }



  /*

  puts(""final"");

  rep(i,_size){

    if( dp[phase][state[i]] != -1 ) {

      bitset<12> BIT(state[i]);

      for(int j=0;j<12;j+=2){

        cout << BIT[j] << BIT[j+1] << "" "";

      } 

      cout << "" = "" << dp[phase][state[i]] << endl;

    }

  }

  */

  if( dp[phase][0] != -1 ) mini = min(mini,dp[phase][0]);

  if( mini != IINF ) printf(""%d\n"",mini-2);

  else puts(""0"");

}



int main(){





  while( scanf(""%d %d"",&h,&w), h|w ){

    rep(i,h) rep(j,w) scanf(""%d"",&field[i][j]);

    compute();

  }

  return 0;

}",54.35,214.0,178.0,C++,cpp
u116766943,p00849,C++,s755775167,420.0,9780.0,Accepted,"#include<bits/stdc++.h>



#define REP(i,s,n) for(int i=s;i<n;i++)

#define rep(i,n) REP(i,0,n)



using namespace std;



const int IINF = INT_MAX;

const int MAX_W = 9;

typedef pair<int,int> ii;





int h,w;

int field[10][10],indice[10][10];

int dp[2][1<<((MAX_W+1)*2)];

int dx[] = {1,0,-1,0};

int dy[] = {0,1,0,-1};



inline bool isValid(int x,int y) { return 0 <= x && x < w && 0 <= y && y < h; }



#define SET(bitmask,index,value) ( bitmask = ( ( bitmask & ~(1<<(2*index)) & ~(1<<(2*index+1)) ) | ( value << (index*2) ) ) )

#define GET(bitmask,x) ( ( ( bitmask >> ( 2 * x ) ) & 1 ) | ( ( ( bitmask >> (2*x+1) ) & 1) << 1 ) )

#define FIX(bitmask) ((bitmask<<2)&((1<<(2*(w+1)))-1))

#define STAR ( field[y][x] == 2 || field[y][x] == 3 )

#define update(x,v) ( ( x == -1 ) ? ( x = v ) : ( x = min(x,v) ) )





void compute(){



  vector<int> state;

  rep(bitmask,(1<<((w+1)*2))) {

    bool success = true;

    for(int i=0;i<(w+1)*2;i+=2) if( ( ( bitmask >> i ) & 1 ) && ( ( bitmask >> (i+1) ) & 1 ) ) { success = false; break; }

    if( success ) state.push_back(bitmask);

  }

  memset(dp,-1,sizeof(dp));



  int _size = state.size();

  bool initter = true, phase = false;

  int mini = IINF;

  int encounter = 0;

  rep(y,h){

    rep(x,w){



      if( field[y][x] == 2 || field[y][x] == 3 ) ++encounter;

      if( initter ) dp[phase][0] = 0;



      rep(i,_size){

        int bitmask = state[i];



        if( dp[phase][bitmask] == -1 ) continue;



        // ?????????

        if( field[y][x] == 1 ) {

          int nbitmask = bitmask;

          SET(nbitmask,x,0);

          if( x == w-1 ) nbitmask = FIX(nbitmask);

          update(dp[!phase][nbitmask],dp[phase][bitmask]);

          continue;

        }



        int nbitmask;

        // 0 0

        if( !( ( GET(bitmask,x) == 0 ) && ( GET(bitmask,(x+1)) == 0 ) ) ) goto Label1;

        if( STAR ) {

          // x 0

          if( y+1 < h && field[y+1][x] != 1 ) {

            nbitmask = bitmask;

            SET(nbitmask,x,((field[y][x]==3)+1));

            if( x == w-1 ) nbitmask = FIX(nbitmask);

          

            update(dp[!phase][nbitmask],dp[phase][bitmask]+1);

          }

          // 0 x

          if( x+1 < w && field[y][x+1] != 1 ) {

            nbitmask = bitmask;

            SET(nbitmask,(x+1),((field[y][x]==3)+1));



            if( x == w-1 ) nbitmask = FIX(nbitmask);



            update(dp[!phase][nbitmask],dp[phase][bitmask]+1);

          }

        } else {

          // x x

          if( x+1 < w && y+1 < h && field[y][x+1] != 1 && field[y+1][x] != 1 ) {

            REP(color,1,3){

              nbitmask = bitmask;

              SET(nbitmask,x,color);

              SET(nbitmask,(x+1),color);

              if( x == w-1 ) nbitmask = FIX(nbitmask);

              update(dp[!phase][nbitmask],(dp[phase][bitmask]+1));

            }

          }

          // 0 0

          nbitmask = bitmask;

          SET(nbitmask,x,0);

          SET(nbitmask,(x+1),0);

          if( x == w-1 ) nbitmask = FIX(nbitmask);

          update(dp[!phase][nbitmask],dp[phase][bitmask]);

        }



        continue;

      Label1:;

        // x 0

        // 0 x

        int color;

        if( !( ( GET(bitmask,x) && ( GET(bitmask,(x+1)) == 0 ) ) || ( GET(bitmask,(x+1)) && ( GET(bitmask,x) == 0 ) ) ) ) goto Label2;

        color = GET(bitmask,x) | GET(bitmask,(x+1));

        if( STAR ) {

          // 0 0

          if( ((color==1)?2:3) == field[y][x] ) {

            nbitmask = bitmask;

            SET(nbitmask,x,0);

            SET(nbitmask,(x+1),0);

            if( x == w-1 ) nbitmask = FIX(nbitmask);

            update(dp[!phase][nbitmask],dp[phase][bitmask]+1);

          }

        } else {

          // x 0

          if( y+1 < h && field[y+1][x] != 1 ) {

            nbitmask = bitmask;

            SET(nbitmask,x,color);

            SET(nbitmask,(x+1),0);

            if( x == w-1 ) nbitmask = FIX(nbitmask);





            update(dp[!phase][nbitmask],(dp[phase][bitmask]+1));

          }

          

          // 0 x

          if( x+1 < w && field[y][x+1] != 1 ) {

            nbitmask = bitmask;

            SET(nbitmask,x,0);

            SET(nbitmask,(x+1),color);



            if( x == w-1 ) nbitmask = FIX(nbitmask);

            update(dp[!phase][nbitmask],(dp[phase][bitmask]+1));

          }

        }

        continue;

      Label2:;

        // x x

        if( !( GET(bitmask,x) && GET(bitmask,(x+1)) ) ) goto Label3;

        if( GET(bitmask,x) != GET(bitmask,(x+1)) ) goto Label3;



        color = GET(bitmask,x);

        

        // 0 0

        if( !STAR ) {

          nbitmask = bitmask;

          SET(nbitmask,x,0);

          SET(nbitmask,(x+1),0);

          if( x == w-1 ) nbitmask = FIX(nbitmask);

          update(dp[!phase][nbitmask],dp[phase][bitmask]+1);

        }

      Label3:;



      }

      if( field[y][x] == 2 || field[y][x] == 3 ) initter = false;

      rep(i,_size) dp[phase][state[i]] = -1;

      if( encounter >= 4 && dp[!phase][0] != -1 ) {

        mini = min(mini,dp[!phase][0]);

      }

      phase = !phase;

    }

  }

  if( dp[phase][0] != -1 ) mini = min(mini,dp[phase][0]);

  if( mini != IINF ) printf(""%d\n"",mini-2);

  else puts(""0"");

}



int main(){

  while( scanf(""%d %d"",&h,&w), h|w ){

    rep(i,h) rep(j,w) scanf(""%d"",&field[i][j]);

    compute();

  }

  return 0;

}",54.35,214.0,178.0,C++,cpp
u116766943,p00849,C++,s755775167,420.0,9780.0,Accepted,"#include<bits/stdc++.h>



#define REP(i,s,n) for(int i=s;i<n;i++)

#define rep(i,n) REP(i,0,n)



using namespace std;



const int IINF = INT_MAX;

const int MAX_W = 9;

typedef pair<int,int> ii;





int h,w;

int field[10][10],indice[10][10];

int dp[2][1<<((MAX_W+1)*2)];

int dx[] = {1,0,-1,0};

int dy[] = {0,1,0,-1};



inline bool isValid(int x,int y) { return 0 <= x && x < w && 0 <= y && y < h; }



#define SET(bitmask,index,value) ( bitmask = ( ( bitmask & ~(1<<(2*index)) & ~(1<<(2*index+1)) ) | ( value << (index*2) ) ) )

#define GET(bitmask,x) ( ( ( bitmask >> ( 2 * x ) ) & 1 ) | ( ( ( bitmask >> (2*x+1) ) & 1) << 1 ) )

#define FIX(bitmask) ((bitmask<<2)&((1<<(2*(w+1)))-1))

#define STAR ( field[y][x] == 2 || field[y][x] == 3 )

#define update(x,v) ( ( x == -1 ) ? ( x = v ) : ( x = min(x,v) ) )





void compute(){



  vector<int> state;

  rep(bitmask,(1<<((w+1)*2))) {

    bool success = true;

    for(int i=0;i<(w+1)*2;i+=2) if( ( ( bitmask >> i ) & 1 ) && ( ( bitmask >> (i+1) ) & 1 ) ) { success = false; break; }

    if( success ) state.push_back(bitmask);

  }

  memset(dp,-1,sizeof(dp));



  int _size = state.size();

  bool initter = true, phase = false;

  int mini = IINF;

  int encounter = 0;

  rep(y,h){

    rep(x,w){



      if( field[y][x] == 2 || field[y][x] == 3 ) ++encounter;

      if( initter ) dp[phase][0] = 0;



      rep(i,_size){

        int bitmask = state[i];



        if( dp[phase][bitmask] == -1 ) continue;



        // ?????????

        if( field[y][x] == 1 ) {

          int nbitmask = bitmask;

          SET(nbitmask,x,0);

          if( x == w-1 ) nbitmask = FIX(nbitmask);

          update(dp[!phase][nbitmask],dp[phase][bitmask]);

          continue;

        }



        int nbitmask;

        // 0 0

        if( !( ( GET(bitmask,x) == 0 ) && ( GET(bitmask,(x+1)) == 0 ) ) ) goto Label1;

        if( STAR ) {

          // x 0

          if( y+1 < h && field[y+1][x] != 1 ) {

            nbitmask = bitmask;

            SET(nbitmask,x,((field[y][x]==3)+1));

            if( x == w-1 ) nbitmask = FIX(nbitmask);

          

            update(dp[!phase][nbitmask],dp[phase][bitmask]+1);

          }

          // 0 x

          if( x+1 < w && field[y][x+1] != 1 ) {

            nbitmask = bitmask;

            SET(nbitmask,(x+1),((field[y][x]==3)+1));



            if( x == w-1 ) nbitmask = FIX(nbitmask);



            update(dp[!phase][nbitmask],dp[phase][bitmask]+1);

          }

        } else {

          // x x

          if( x+1 < w && y+1 < h && field[y][x+1] != 1 && field[y+1][x] != 1 ) {

            REP(color,1,3){

              nbitmask = bitmask;

              SET(nbitmask,x,color);

              SET(nbitmask,(x+1),color);

              if( x == w-1 ) nbitmask = FIX(nbitmask);

              update(dp[!phase][nbitmask],(dp[phase][bitmask]+1));

            }

          }

          // 0 0

          nbitmask = bitmask;

          SET(nbitmask,x,0);

          SET(nbitmask,(x+1),0);

          if( x == w-1 ) nbitmask = FIX(nbitmask);

          update(dp[!phase][nbitmask],dp[phase][bitmask]);

        }



        continue;

      Label1:;

        // x 0

        // 0 x

        int color;

        if( !( ( GET(bitmask,x) && ( GET(bitmask,(x+1)) == 0 ) ) || ( GET(bitmask,(x+1)) && ( GET(bitmask,x) == 0 ) ) ) ) goto Label2;

        color = GET(bitmask,x) | GET(bitmask,(x+1));

        if( STAR ) {

          // 0 0

          if( ((color==1)?2:3) == field[y][x] ) {

            nbitmask = bitmask;

            SET(nbitmask,x,0);

            SET(nbitmask,(x+1),0);

            if( x == w-1 ) nbitmask = FIX(nbitmask);

            update(dp[!phase][nbitmask],dp[phase][bitmask]+1);

          }

        } else {

          // x 0

          if( y+1 < h && field[y+1][x] != 1 ) {

            nbitmask = bitmask;

            SET(nbitmask,x,color);

            SET(nbitmask,(x+1),0);

            if( x == w-1 ) nbitmask = FIX(nbitmask);





            update(dp[!phase][nbitmask],(dp[phase][bitmask]+1));

          }

          

          // 0 x

          if( x+1 < w && field[y][x+1] != 1 ) {

            nbitmask = bitmask;

            SET(nbitmask,x,0);

            SET(nbitmask,(x+1),color);



            if( x == w-1 ) nbitmask = FIX(nbitmask);

            update(dp[!phase][nbitmask],(dp[phase][bitmask]+1));

          }

        }

        continue;

      Label2:;

        // x x

        if( !( GET(bitmask,x) && GET(bitmask,(x+1)) ) ) goto Label3;

        if( GET(bitmask,x) != GET(bitmask,(x+1)) ) goto Label3;



        color = GET(bitmask,x);

        

        // 0 0

        if( !STAR ) {

          nbitmask = bitmask;

          SET(nbitmask,x,0);

          SET(nbitmask,(x+1),0);

          if( x == w-1 ) nbitmask = FIX(nbitmask);

          update(dp[!phase][nbitmask],dp[phase][bitmask]+1);

        }

      Label3:;



      }

      if( field[y][x] == 2 || field[y][x] == 3 ) initter = false;

      rep(i,_size) dp[phase][state[i]] = -1;

      if( encounter >= 4 && dp[!phase][0] != -1 ) {

        mini = min(mini,dp[!phase][0]);

      }

      phase = !phase;

    }

  }

  if( dp[phase][0] != -1 ) mini = min(mini,dp[phase][0]);

  if( mini != IINF ) printf(""%d\n"",mini-2);

  else puts(""0"");

}



int main(){

  while( scanf(""%d %d"",&h,&w), h|w ){

    rep(i,h) rep(j,w) scanf(""%d"",&field[i][j]);

    compute();

  }

  return 0;

}",2.38,178.0,179.0,C++,cpp
u116766943,p00849,C++,s221324014,410.0,9780.0,Accepted,"#include<bits/stdc++.h>



#define REP(i,s,n) for(int i=s;i<n;i++)

#define rep(i,n) REP(i,0,n)



using namespace std;



const int IINF = INT_MAX;

const int MAX_W = 9;

typedef pair<int,int> ii;





int h,w;

int field[10][10],indice[10][10];

int dp[2][1<<((MAX_W+1)*2)];

int dx[] = {1,0,-1,0};

int dy[] = {0,1,0,-1};



inline bool isValid(int x,int y) { return 0 <= x && x < w && 0 <= y && y < h; }



#define SET(bitmask,index,value) ( bitmask = ( ( bitmask & ~(1<<(2*index)) & ~(1<<(2*index+1)) ) | ( value << (index*2) ) ) )

#define GET(bitmask,x) ( ( ( bitmask >> ( 2 * x ) ) & 1 ) | ( ( ( bitmask >> (2*x+1) ) & 1) << 1 ) )

#define FIX(bitmask) ((bitmask<<2)&((1<<(2*(w+1)))-1))

#define STAR ( field[y][x] == 2 || field[y][x] == 3 )

#define update(x,v) ( ( x == -1 ) ? ( x = v ) : ( x = min(x,v) ) )





void compute(){



  vector<int> state;

  rep(bitmask,(1<<((w+1)*2))) {

    bool success = true;

    for(int i=0;i<(w+1)*2;i+=2) if( ( ( bitmask >> i ) & 1 ) && ( ( bitmask >> (i+1) ) & 1 ) ) { success = false; break; }

    if( success ) state.push_back(bitmask);

  }

  memset(dp,-1,sizeof(dp));



  int _size = state.size();

  bool initter = true, phase = false;

  int mini = IINF;

  int encounter = 0;

  rep(y,h){

    rep(x,w){



      if( field[y][x] == 2 || field[y][x] == 3 ) ++encounter;

      if( initter ) dp[phase][0] = 0;



      rep(i,_size){

        int bitmask = state[i];



        if( dp[phase][bitmask] == -1 ) continue;

        if( dp[phase][bitmask] >= mini ) continue;



        // ?????????

        if( field[y][x] == 1 ) {

          int nbitmask = bitmask;

          SET(nbitmask,x,0);

          if( x == w-1 ) nbitmask = FIX(nbitmask);

          update(dp[!phase][nbitmask],dp[phase][bitmask]);

          continue;

        }



        int nbitmask;

        // 0 0

        if( !( ( GET(bitmask,x) == 0 ) && ( GET(bitmask,(x+1)) == 0 ) ) ) goto Label1;

        if( STAR ) {

          // x 0

          if( y+1 < h && field[y+1][x] != 1 ) {

            nbitmask = bitmask;

            SET(nbitmask,x,((field[y][x]==3)+1));

            if( x == w-1 ) nbitmask = FIX(nbitmask);

          

            update(dp[!phase][nbitmask],dp[phase][bitmask]+1);

          }

          // 0 x

          if( x+1 < w && field[y][x+1] != 1 ) {

            nbitmask = bitmask;

            SET(nbitmask,(x+1),((field[y][x]==3)+1));



            if( x == w-1 ) nbitmask = FIX(nbitmask);



            update(dp[!phase][nbitmask],dp[phase][bitmask]+1);

          }

        } else {

          // x x

          if( x+1 < w && y+1 < h && field[y][x+1] != 1 && field[y+1][x] != 1 ) {

            REP(color,1,3){

              nbitmask = bitmask;

              SET(nbitmask,x,color);

              SET(nbitmask,(x+1),color);

              if( x == w-1 ) nbitmask = FIX(nbitmask);

              update(dp[!phase][nbitmask],(dp[phase][bitmask]+1));

            }

          }

          // 0 0

          nbitmask = bitmask;

          SET(nbitmask,x,0);

          SET(nbitmask,(x+1),0);

          if( x == w-1 ) nbitmask = FIX(nbitmask);

          update(dp[!phase][nbitmask],dp[phase][bitmask]);

        }



        continue;

      Label1:;

        // x 0

        // 0 x

        int color;

        if( !( ( GET(bitmask,x) && ( GET(bitmask,(x+1)) == 0 ) ) || ( GET(bitmask,(x+1)) && ( GET(bitmask,x) == 0 ) ) ) ) goto Label2;

        color = GET(bitmask,x) | GET(bitmask,(x+1));

        if( STAR ) {

          // 0 0

          if( ((color==1)?2:3) == field[y][x] ) {

            nbitmask = bitmask;

            SET(nbitmask,x,0);

            SET(nbitmask,(x+1),0);

            if( x == w-1 ) nbitmask = FIX(nbitmask);

            update(dp[!phase][nbitmask],dp[phase][bitmask]+1);

          }

        } else {

          // x 0

          if( y+1 < h && field[y+1][x] != 1 ) {

            nbitmask = bitmask;

            SET(nbitmask,x,color);

            SET(nbitmask,(x+1),0);

            if( x == w-1 ) nbitmask = FIX(nbitmask);





            update(dp[!phase][nbitmask],(dp[phase][bitmask]+1));

          }

          

          // 0 x

          if( x+1 < w && field[y][x+1] != 1 ) {

            nbitmask = bitmask;

            SET(nbitmask,x,0);

            SET(nbitmask,(x+1),color);



            if( x == w-1 ) nbitmask = FIX(nbitmask);

            update(dp[!phase][nbitmask],(dp[phase][bitmask]+1));

          }

        }

        continue;

      Label2:;

        // x x

        if( !( GET(bitmask,x) && GET(bitmask,(x+1)) ) ) goto Label3;

        if( GET(bitmask,x) != GET(bitmask,(x+1)) ) goto Label3;



        color = GET(bitmask,x);

        

        // 0 0

        if( !STAR ) {

          nbitmask = bitmask;

          SET(nbitmask,x,0);

          SET(nbitmask,(x+1),0);

          if( x == w-1 ) nbitmask = FIX(nbitmask);

          update(dp[!phase][nbitmask],dp[phase][bitmask]+1);

        }

      Label3:;



      }

      if( field[y][x] == 2 || field[y][x] == 3 ) initter = false;

      rep(i,_size) dp[phase][state[i]] = -1;

      if( encounter >= 4 && dp[!phase][0] != -1 ) {

        mini = min(mini,dp[!phase][0]);

      }

      phase = !phase;

    }

  }

  if( dp[phase][0] != -1 ) mini = min(mini,dp[phase][0]);

  if( mini != IINF ) printf(""%d\n"",mini-2);

  else puts(""0"");

}



int main(){

  while( scanf(""%d %d"",&h,&w), h|w ){

    rep(i,h) rep(j,w) scanf(""%d"",&field[i][j]);

    compute();

  }

  return 0;

}",2.38,178.0,179.0,C++,cpp
u157643087,p00849,C++,s939749011,9990.0,872.0,Time Limit Exceeded,"#include<iostream>

#include<algorithm>

using namespace std;

#define REP(i,b,n) for(int i=b;i<n;i++)

#define rep(i,n)   REP(i,0,n)



const int N = 9;

const int inf = (1 <<21);



int dx[]={0,1, 0,-1};

int dy[]={1,0,-1,0};

int op[]={2,3, 0,1};

int m[N][N];

bool vis2[N][N];



bool isok(int r,int c,int y,int x,int last){

  rep(i,4){

    if (op[i] == last)continue;

    int nex=x+dx[i],ney=y+dy[i];

    if (nex==-1||ney==-1||nex==c||ney==r)continue;

    if (vis2[ney][nex])return false;

  }

  return true;

}



void output(int r,int c){

  cout << ""begin""<<endl;

  rep(i,r){

    rep(j,c){

      if (vis2[i][j])cout << 2;

      else cout << '0';

    }

    cout << endl;

  }

  cout <<endl;

}





int ans;

bool isgoal;

int md;

bool bfs(int r,int c,int cnt,bool goal2){

  static int q[N*N];

  static int cost[N][N];

  int sy3=-1,sx3=-1,gy3=-1,gx3=-1;

  rep(i,r){

    rep(j,c){

      if (m[i][j] == 3){

	if (sy3==-1)sy3=i,sx3=j;

	else gy3=i,gx3=j;

      }

      cost[i][j]=inf;

    }

  }

  int tail=0,head=0;

  q[tail++]=sx3+sy3*c;

  cost[sy3][sx3]=0;

  while(head != tail){

    int now = q[head++];

    int x = now%c,y=now/c;

    if (cnt+cost[y][x] >= ans)return false;

    if (x == gx3 && y == gy3){

      if (goal2)return true;

      isgoal=true;

      ans =min(ans,cnt+cost[y][x]);

      return true;

    }

    rep(i,4){

      int nex=x+dx[i],ney=y+dy[i];

      if (nex==-1||ney==-1||nex==c||ney==r||vis2[ney][nex])continue;

      if (m[ney][nex]==1||m[ney][nex] == 2)continue;

      if (cost[ney][nex] != inf)continue;

      cost[ney][nex]=cost[y][x]+1;

      q[tail++]=ney*c+nex;

    }

  }

  return false;

}



bool bfs2(int r,int c,int cnt,int sy,int sx){

  static int q[N*N];

  static int cost[N][N];

  int sy3=-1,sx3=-1,gy3=-1,gx3=-1;

  rep(i,r){

    rep(j,c){

      if (m[i][j] == 2){

	if (sy3==-1)sy3=i,sx3=j;

	else gy3=i,gx3=j;

      }

      cost[i][j]=inf;

    }

  }

  int tail=0,head=0;

  q[tail++]=sx+sy*c;

  cost[sy][sx]=0;

  while(head != tail){

    int now = q[head++];

    int x = now%c,y=now/c;

    if (cnt+cost[y][x] >= ans)return false;

    if (x == gx3 && y == gy3){

      return true;

    }

    rep(i,4){

      int nex=x+dx[i],ney=y+dy[i];

      if (nex==-1||ney==-1||nex==c||ney==r||vis2[ney][nex])continue;

      if (m[ney][nex]==1||m[ney][nex] == 3)continue;

      if (cost[ney][nex] != inf)continue;

      cost[ney][nex]=cost[y][x]+1;

      q[tail++]=ney*c+nex;

    }

  }

  return false;

}





int path[N*N];

int pattern[8][5]={

  {2,1,1,0,0,},

  {1,0,0,3,3,},

  {0,3,3,2,2,},

  {3,2,2,1,1,},

  {2,3,3,0,0,},

  {1,2,2,3,3,},

  {0,1,1,2,2,},

  {3,0,0,1,1,},

};



int cx[]={-1, 1,1,-1, 1, 1,-1, -1};

int cy[]={-1,-1,1, 1,-1, 1, 1,-1};



bool isok2(int r,int c,int y,int x,int p){

  if (p <5)return true;

  rep(i,8){

    bool ismatch=true;

    rep(j,5){

      if (pattern[i][j] == path[p-(5-j)]);

      else ismatch=false;

    }

    if (!ismatch)continue;

    int nex=x+cx[i],ney=y+cy[i];

    if (nex==-1||ney==-1||nex==c||ney==r)continue;

    //    cout << ""test""<<endl;

    //    if (m[ney][nex] == 0 && !vis2[ney][nex])cout <<""cut""<<endl;

    if (m[ney][nex] == 0 && !vis2[ney][nex])return false;



  }

  return true;

}



void dfs(int r,int c,int y,int x,int cnt,int last,int gy2,int gx2){

  if (!isok(r,c,y,x,last)){

    return;

  }

  if (!isok2(r,c,y,x,cnt))return;



  if (cnt+md >= ans)return;

  if (!bfs(r,c,cnt,true))return;



  //  if (!bfs2(r,c,cnt,gy2,gx2))return;

  /*

  for(int i=0;cnt >=5 && i<5;i++){

    cout << path[cnt-5+i]<<"" "";

  }

  cout << endl;

  vis2[y][x]=true;

  output(r,c);

  vis2[y][x]=false;

  */    



  if (x == gx2 && y == gy2){

    vis2[y][x]=true;

    bfs(r,c,cnt,false);

    vis2[y][x]=false;

    return;

  }



  vis2[y][x]=true;

  rep(i,4){

    if (op[i] == last)continue;

    int nex=x+dx[i],ney=y+dy[i];

    if (nex==-1||ney==-1||nex==c||ney==r||vis2[ney][nex])continue;

    if (m[ney][nex] == 3 || m[ney][nex] == 1)continue;

    path[cnt]=i;

    dfs(r,c,ney,nex,cnt+1,i,gy2,gx2);

  }

  vis2[y][x]=false;

}



int bfs2(int r,int c,int tar,int utar){

  static int q[N*N];

  static int cost[N][N];

  int sy3=-1,sx3=-1,gy3=-1,gx3=-1;

  rep(i,r){

    rep(j,c){

      if (m[i][j] == tar){

	if (sy3==-1)sy3=i,sx3=j;

	else gy3=i,gx3=j;

      }

      cost[i][j]=inf;

    }

  }

  int tail=0,head=0;

  q[tail++]=sx3+sy3*c;

  cost[sy3][sx3]=0;

  while(head != tail){

    int now = q[head++];

    int x = now%c,y=now/c;



    if (x == gx3 && y == gy3){

      return cost[y][x];

    }

    rep(i,4){

      int nex=x+dx[i],ney=y+dy[i];

      if (nex==-1||ney==-1||nex==c||ney==r||vis2[ney][nex])continue;

      if (m[ney][nex]==1||m[ney][nex] == utar)continue;

      if (cost[ney][nex] != inf)continue;

      cost[ney][nex]=cost[y][x]+1;

      q[tail++]=ney*c+nex;

    }

  }

  return false;

}







main(){

  int r,c;

  while(cin>>r>>c && r){

    ans = r*c;

    isgoal=false;

    rep(i,r)rep(j,c)cin>>m[i][j];

    rep(i,r)rep(j,c)vis2[i][j]=false;







    

    int sx2=-1,sy2=-1;

    int gx2=-1,gy2=-1;

    rep(i,r){

      rep(j,c){

	if (m[i][j] == 2){

	  if (sx2 == -1)sx2=j,sy2=i;

	  else gx2=j,gy2=i;

	}

      }

    }

    

    int sx3=-1,sy3=-1,gx3=-1,gy3=-1;

    rep(i,r){

      rep(j,c){

	if (m[i][j] == 3){

	  if (sx3 == -1)sx3=j,sy3=i;

	  else gx3=j,gy3=i;

	}

      }

    }





    /*

    md = max(sx3,gx3)-min(sx3,gx3)+

      max(sy3,gy3)-min(sy3,gy3);

    */

    md=bfs2(r,c,3,2);





    

    dfs(r,c,sy2,sx2,0,-1,gy2,gx2);

    

    if (isgoal)cout << ans << endl;

    else cout << 0 << endl;

  }

  return false;

}",15.72,273.0,259.0,C++,cpp
u157643087,p00849,C++,s752272632,8420.0,872.0,Time Limit Exceeded,"#include<iostream>

#include<algorithm>

using namespace std;

#define REP(i,b,n) for(int i=b;i<n;i++)

#define rep(i,n)   REP(i,0,n)



const int N = 9;

const int inf = (1 <<21);



int dx[]={0,1, 0,-1};

int dy[]={1,0,-1,0};

int op[]={2,3, 0,1};

int m[N][N];

bool vis2[N][N];



bool isok(int r,int c,int y,int x,int last){

  rep(i,4){

    if (op[i] == last)continue;

    int nex=x+dx[i],ney=y+dy[i];

    if (nex==-1||ney==-1||nex==c||ney==r)continue;

    if (vis2[ney][nex])return false;

  }

  return true;

}



void output(int r,int c){

  cout << ""begin""<<endl;

  rep(i,r){

    rep(j,c){

      if (vis2[i][j])cout << 2;

      else cout << '0';

    }

    cout << endl;

  }

  cout <<endl;

}





int ans;

bool isgoal;

int md;

bool bfs(int r,int c,int cnt,bool goal2){

  static int q[N*N];

  static int cost[N][N];

  int sy3=-1,sx3=-1,gy3=-1,gx3=-1;

  rep(i,r){

    rep(j,c){

      if (m[i][j] == 3){

	if (sy3==-1)sy3=i,sx3=j;

	else gy3=i,gx3=j;

      }

      cost[i][j]=inf;

    }

  }

  int tail=0,head=0;

  q[tail++]=sx3+sy3*c;

  cost[sy3][sx3]=0;

  while(head != tail){

    int now = q[head++];

    int x = now%c,y=now/c;

    if (cnt+cost[y][x] >= ans)return false;

    if (x == gx3 && y == gy3){

      if (goal2)return true;

      isgoal=true;

      ans =min(ans,cnt+cost[y][x]);

      return true;

    }

    rep(i,4){

      int nex=x+dx[i],ney=y+dy[i];

      if (nex==-1||ney==-1||nex==c||ney==r||vis2[ney][nex])continue;

      if (m[ney][nex]==1||m[ney][nex] == 2)continue;

      if (cost[ney][nex] != inf)continue;

      cost[ney][nex]=cost[y][x]+1;

      q[tail++]=ney*c+nex;

    }

  }

  return false;

}



bool bfs2(int r,int c,int cnt,int sy,int sx){

  static int q[N*N];

  static int cost[N][N];

  int sy3=-1,sx3=-1,gy3=-1,gx3=-1;

  rep(i,r){

    rep(j,c){

      if (m[i][j] == 2){

	if (sy3==-1)sy3=i,sx3=j;

	else gy3=i,gx3=j;

      }

      cost[i][j]=inf;

    }

  }

  int tail=0,head=0;

  q[tail++]=sx+sy*c;

  cost[sy][sx]=0;

  while(head != tail){

    int now = q[head++];

    int x = now%c,y=now/c;

    if (cnt+cost[y][x] >= ans)return false;

    if (x == gx3 && y == gy3){

      return true;

    }

    rep(i,4){

      int nex=x+dx[i],ney=y+dy[i];

      if (nex==-1||ney==-1||nex==c||ney==r||vis2[ney][nex])continue;

      if (m[ney][nex]==1||m[ney][nex] == 3)continue;

      if (cost[ney][nex] != inf)continue;

      cost[ney][nex]=cost[y][x]+1;

      q[tail++]=ney*c+nex;

    }

  }

  return false;

}





int path[N*N];

int pattern[8][4]={

  {2,1,1,0,},

  {1,0,0,3,},

  {0,3,3,2,},

  {3,2,2,1,},

  {2,3,3,0,},

  {1,2,2,3,},

  {0,1,1,2,},

  {3,0,0,1,},

};



int cx[]={-1, 0,1, 0, 1, 0,-1, 0};

int cy[]={ 0,-1,0, 1, 0, 1, 0,-1};



bool isok2(int r,int c,int y,int x,int p){

  if (p <4)return true;

  rep(i,8){

    bool ismatch=true;

    rep(j,4){

      if (pattern[i][j] == path[p-(4-j)]);

      else ismatch=false;

    }

    if (!ismatch)continue;

    int nex=x+cx[i],ney=y+cy[i];

    if (nex==-1||ney==-1||nex==c||ney==r)continue;

    if (m[ney][nex] == 0 && !vis2[ney][nex])return false;



  }

  return true;

}



void dfs(int r,int c,int y,int x,int cnt,int last,int gy2,int gx2){

  if (!isok(r,c,y,x,last)){

    return;

  }

  if (!isok2(r,c,y,x,cnt))return;



  if (cnt+md >= ans)return;

  if (!bfs(r,c,cnt,true))return;



  if (!bfs2(r,c,cnt,gy2,gx2))return;



  /*

  for(int i=0;cnt >=5 && i<5;i++){

    cout << path[cnt-5+i]<<"" "";

  }

  cout << endl;

  vis2[y][x]=true;

  output(r,c);

  vis2[y][x]=false;

  */      



  if (x == gx2 && y == gy2){

    vis2[y][x]=true;

    bfs(r,c,cnt,false);

    vis2[y][x]=false;

    return;

  }



  vis2[y][x]=true;

  rep(i,4){

    if (op[i] == last)continue;

    int nex=x+dx[i],ney=y+dy[i];

    if (nex==-1||ney==-1||nex==c||ney==r||vis2[ney][nex])continue;

    if (m[ney][nex] == 3 || m[ney][nex] == 1)continue;

    path[cnt]=i;

    dfs(r,c,ney,nex,cnt+1,i,gy2,gx2);

  }

  vis2[y][x]=false;

}



int bfs2(int r,int c,int tar,int utar){

  static int q[N*N];

  static int cost[N][N];

  int sy3=-1,sx3=-1,gy3=-1,gx3=-1;

  rep(i,r){

    rep(j,c){

      if (m[i][j] == tar){

	if (sy3==-1)sy3=i,sx3=j;

	else gy3=i,gx3=j;

      }

      cost[i][j]=inf;

    }

  }

  int tail=0,head=0;

  q[tail++]=sx3+sy3*c;

  cost[sy3][sx3]=0;

  while(head != tail){

    int now = q[head++];

    int x = now%c,y=now/c;

    if (x == gx3 && y == gy3){

      return cost[y][x];

    }

    rep(i,4){

      int nex=x+dx[i],ney=y+dy[i];

      if (nex==-1||ney==-1||nex==c||ney==r||vis2[ney][nex])continue;

      if (m[ney][nex]==1||m[ney][nex] == utar)continue;

      if (cost[ney][nex] != inf)continue;

      cost[ney][nex]=cost[y][x]+1;

      q[tail++]=ney*c+nex;

    }

  }

  return false;

}



main(){

  int r,c;

  while(cin>>r>>c && r){

    ans = r*c;

    isgoal=false;

    rep(i,r)rep(j,c)cin>>m[i][j];

    rep(i,r)rep(j,c)vis2[i][j]=false;

   

    int sx2=-1,sy2=-1;

    int gx2=-1,gy2=-1;

    rep(i,r){

      rep(j,c){

	if (m[i][j] == 2){

	  if (sx2 == -1)sx2=j,sy2=i;

	  else gx2=j,gy2=i;

	}

      }

    }

    

    int sx3=-1,sy3=-1,gx3=-1,gy3=-1;

    rep(i,r){

      rep(j,c){

	if (m[i][j] == 3){

	  if (sx3 == -1)sx3=j,sy3=i;

	  else gx3=j,gy3=i;

	}

      }

    }



    md=bfs2(r,c,3,2);

    

    dfs(r,c,sy2,sx2,0,-1,gy2,gx2);

    

    if (isgoal)cout << ans << endl;

    else cout << 0 << endl;

  }

  return false;

}",15.72,273.0,259.0,C++,cpp
u157643087,p00849,C++,s752272632,8420.0,872.0,Time Limit Exceeded,"#include<iostream>

#include<algorithm>

using namespace std;

#define REP(i,b,n) for(int i=b;i<n;i++)

#define rep(i,n)   REP(i,0,n)



const int N = 9;

const int inf = (1 <<21);



int dx[]={0,1, 0,-1};

int dy[]={1,0,-1,0};

int op[]={2,3, 0,1};

int m[N][N];

bool vis2[N][N];



bool isok(int r,int c,int y,int x,int last){

  rep(i,4){

    if (op[i] == last)continue;

    int nex=x+dx[i],ney=y+dy[i];

    if (nex==-1||ney==-1||nex==c||ney==r)continue;

    if (vis2[ney][nex])return false;

  }

  return true;

}



void output(int r,int c){

  cout << ""begin""<<endl;

  rep(i,r){

    rep(j,c){

      if (vis2[i][j])cout << 2;

      else cout << '0';

    }

    cout << endl;

  }

  cout <<endl;

}





int ans;

bool isgoal;

int md;

bool bfs(int r,int c,int cnt,bool goal2){

  static int q[N*N];

  static int cost[N][N];

  int sy3=-1,sx3=-1,gy3=-1,gx3=-1;

  rep(i,r){

    rep(j,c){

      if (m[i][j] == 3){

	if (sy3==-1)sy3=i,sx3=j;

	else gy3=i,gx3=j;

      }

      cost[i][j]=inf;

    }

  }

  int tail=0,head=0;

  q[tail++]=sx3+sy3*c;

  cost[sy3][sx3]=0;

  while(head != tail){

    int now = q[head++];

    int x = now%c,y=now/c;

    if (cnt+cost[y][x] >= ans)return false;

    if (x == gx3 && y == gy3){

      if (goal2)return true;

      isgoal=true;

      ans =min(ans,cnt+cost[y][x]);

      return true;

    }

    rep(i,4){

      int nex=x+dx[i],ney=y+dy[i];

      if (nex==-1||ney==-1||nex==c||ney==r||vis2[ney][nex])continue;

      if (m[ney][nex]==1||m[ney][nex] == 2)continue;

      if (cost[ney][nex] != inf)continue;

      cost[ney][nex]=cost[y][x]+1;

      q[tail++]=ney*c+nex;

    }

  }

  return false;

}



bool bfs2(int r,int c,int cnt,int sy,int sx){

  static int q[N*N];

  static int cost[N][N];

  int sy3=-1,sx3=-1,gy3=-1,gx3=-1;

  rep(i,r){

    rep(j,c){

      if (m[i][j] == 2){

	if (sy3==-1)sy3=i,sx3=j;

	else gy3=i,gx3=j;

      }

      cost[i][j]=inf;

    }

  }

  int tail=0,head=0;

  q[tail++]=sx+sy*c;

  cost[sy][sx]=0;

  while(head != tail){

    int now = q[head++];

    int x = now%c,y=now/c;

    if (cnt+cost[y][x] >= ans)return false;

    if (x == gx3 && y == gy3){

      return true;

    }

    rep(i,4){

      int nex=x+dx[i],ney=y+dy[i];

      if (nex==-1||ney==-1||nex==c||ney==r||vis2[ney][nex])continue;

      if (m[ney][nex]==1||m[ney][nex] == 3)continue;

      if (cost[ney][nex] != inf)continue;

      cost[ney][nex]=cost[y][x]+1;

      q[tail++]=ney*c+nex;

    }

  }

  return false;

}





int path[N*N];

int pattern[8][4]={

  {2,1,1,0,},

  {1,0,0,3,},

  {0,3,3,2,},

  {3,2,2,1,},

  {2,3,3,0,},

  {1,2,2,3,},

  {0,1,1,2,},

  {3,0,0,1,},

};



int cx[]={-1, 0,1, 0, 1, 0,-1, 0};

int cy[]={ 0,-1,0, 1, 0, 1, 0,-1};



bool isok2(int r,int c,int y,int x,int p){

  if (p <4)return true;

  rep(i,8){

    bool ismatch=true;

    rep(j,4){

      if (pattern[i][j] == path[p-(4-j)]);

      else ismatch=false;

    }

    if (!ismatch)continue;

    int nex=x+cx[i],ney=y+cy[i];

    if (nex==-1||ney==-1||nex==c||ney==r)continue;

    if (m[ney][nex] == 0 && !vis2[ney][nex])return false;



  }

  return true;

}



void dfs(int r,int c,int y,int x,int cnt,int last,int gy2,int gx2){

  if (!isok(r,c,y,x,last)){

    return;

  }

  if (!isok2(r,c,y,x,cnt))return;



  if (cnt+md >= ans)return;

  if (!bfs(r,c,cnt,true))return;



  if (!bfs2(r,c,cnt,gy2,gx2))return;



  /*

  for(int i=0;cnt >=5 && i<5;i++){

    cout << path[cnt-5+i]<<"" "";

  }

  cout << endl;

  vis2[y][x]=true;

  output(r,c);

  vis2[y][x]=false;

  */      



  if (x == gx2 && y == gy2){

    vis2[y][x]=true;

    bfs(r,c,cnt,false);

    vis2[y][x]=false;

    return;

  }



  vis2[y][x]=true;

  rep(i,4){

    if (op[i] == last)continue;

    int nex=x+dx[i],ney=y+dy[i];

    if (nex==-1||ney==-1||nex==c||ney==r||vis2[ney][nex])continue;

    if (m[ney][nex] == 3 || m[ney][nex] == 1)continue;

    path[cnt]=i;

    dfs(r,c,ney,nex,cnt+1,i,gy2,gx2);

  }

  vis2[y][x]=false;

}



int bfs2(int r,int c,int tar,int utar){

  static int q[N*N];

  static int cost[N][N];

  int sy3=-1,sx3=-1,gy3=-1,gx3=-1;

  rep(i,r){

    rep(j,c){

      if (m[i][j] == tar){

	if (sy3==-1)sy3=i,sx3=j;

	else gy3=i,gx3=j;

      }

      cost[i][j]=inf;

    }

  }

  int tail=0,head=0;

  q[tail++]=sx3+sy3*c;

  cost[sy3][sx3]=0;

  while(head != tail){

    int now = q[head++];

    int x = now%c,y=now/c;

    if (x == gx3 && y == gy3){

      return cost[y][x];

    }

    rep(i,4){

      int nex=x+dx[i],ney=y+dy[i];

      if (nex==-1||ney==-1||nex==c||ney==r||vis2[ney][nex])continue;

      if (m[ney][nex]==1||m[ney][nex] == utar)continue;

      if (cost[ney][nex] != inf)continue;

      cost[ney][nex]=cost[y][x]+1;

      q[tail++]=ney*c+nex;

    }

  }

  return false;

}



main(){

  int r,c;

  while(cin>>r>>c && r){

    ans = r*c;

    isgoal=false;

    rep(i,r)rep(j,c)cin>>m[i][j];

    rep(i,r)rep(j,c)vis2[i][j]=false;

   

    int sx2=-1,sy2=-1;

    int gx2=-1,gy2=-1;

    rep(i,r){

      rep(j,c){

	if (m[i][j] == 2){

	  if (sx2 == -1)sx2=j,sy2=i;

	  else gx2=j,gy2=i;

	}

      }

    }

    

    int sx3=-1,sy3=-1,gx3=-1,gy3=-1;

    rep(i,r){

      rep(j,c){

	if (m[i][j] == 3){

	  if (sx3 == -1)sx3=j,sy3=i;

	  else gx3=j,gy3=i;

	}

      }

    }



    md=bfs2(r,c,3,2);

    

    dfs(r,c,sy2,sx2,0,-1,gy2,gx2);

    

    if (isgoal)cout << ans << endl;

    else cout << 0 << endl;

  }

  return false;

}",12.71,259.0,259.0,C++,cpp
u157643087,p00849,C++,s870368250,7350.0,868.0,Accepted,"#include<iostream>

#include<algorithm>

using namespace std;

#define REP(i,b,n) for(int i=b;i<n;i++)

#define rep(i,n)   REP(i,0,n)



const int N = 9;

const int inf = (1 <<21);



int dx[]={0,1, 0,-1};

int dy[]={1,0,-1,0};

int op[]={2,3, 0,1};

int m[N][N];

bool vis2[N][N];



bool isok(int r,int c,int y,int x,int last){

  rep(i,4){

    if (op[i] == last)continue;

    int nex=x+dx[i],ney=y+dy[i];

    if (nex==-1||ney==-1||nex==c||ney==r)continue;

    if (vis2[ney][nex])return false;

  }

  return true;

}



void output(int r,int c){

  cout << ""begin""<<endl;

  rep(i,r){

    rep(j,c){

      if (vis2[i][j])cout << 2;

      else cout << '0';

    }

    cout << endl;

  }

  cout <<endl;

}





int ans;

bool isgoal;

int md;

bool bfs(int r,int c,int cnt,bool goal2){

  static int q[N*N];

  static int cost[N][N];

  int sy3=-1,sx3=-1,gy3=-1,gx3=-1;

  rep(i,r){

    rep(j,c){

      if (m[i][j] == 3){

	if (sy3==-1)sy3=i,sx3=j;

	else gy3=i,gx3=j;

      }

      cost[i][j]=inf;

    }

  }

  int tail=0,head=0;

  q[tail++]=sx3+sy3*c;

  cost[sy3][sx3]=0;

  while(head != tail){

    int now = q[head++];

    int x = now%c,y=now/c;

    if (cnt+cost[y][x] >= ans)return false;

    if (x == gx3 && y == gy3){

      if (goal2)return true;

      isgoal=true;

      ans =min(ans,cnt+cost[y][x]);

      return true;

    }

    rep(i,4){

      int nex=x+dx[i],ney=y+dy[i];

      if (nex==-1||ney==-1||nex==c||ney==r||vis2[ney][nex])continue;

      if (m[ney][nex]==1||m[ney][nex] == 2)continue;

      if (cost[ney][nex] != inf)continue;

      cost[ney][nex]=cost[y][x]+1;

      q[tail++]=ney*c+nex;

    }

  }

  return false;

}



bool bfs2(int r,int c,int cnt,int sy,int sx){

  static int q[N*N];

  static int cost[N][N];

  int sy3=-1,sx3=-1,gy3=-1,gx3=-1;

  rep(i,r){

    rep(j,c){

      if (m[i][j] == 2){

	if (sy3==-1)sy3=i,sx3=j;

	else gy3=i,gx3=j;

      }

      cost[i][j]=inf;

    }

  }

  int tail=0,head=0;

  q[tail++]=sx+sy*c;

  cost[sy][sx]=0;

  while(head != tail){

    int now = q[head++];

    int x = now%c,y=now/c;

    if (cnt+cost[y][x] >= ans)return false;

    if (x == gx3 && y == gy3){

      return true;

    }

    rep(i,4){

      int nex=x+dx[i],ney=y+dy[i];

      if (nex==-1||ney==-1||nex==c||ney==r||vis2[ney][nex])continue;

      if (m[ney][nex]==1||m[ney][nex] == 3)continue;

      if (cost[ney][nex] != inf)continue;

      cost[ney][nex]=cost[y][x]+1;

      q[tail++]=ney*c+nex;

    }

  }

  return false;

}





int path[N*N];

int pattern[8][4]={

  {2,1,1,0,},

  {1,0,0,3,},

  {0,3,3,2,},

  {3,2,2,1,},

  {2,3,3,0,},

  {1,2,2,3,},

  {0,1,1,2,},

  {3,0,0,1,},

};



int cx[]={-1, 0,1, 0, 1, 0,-1, 0};

int cy[]={ 0,-1,0, 1, 0, 1, 0,-1};



bool isok2(int r,int c,int y,int x,int p){

  if (p <4)return true;

  rep(i,8){

    bool ismatch=true;

    rep(j,4){

      if (pattern[i][j] == path[p-(4-j)]);

      else ismatch=false;

    }

    if (!ismatch)continue;

    int nex=x+cx[i],ney=y+cy[i];

    if (nex==-1||ney==-1||nex==c||ney==r)continue;

    if (m[ney][nex] == 0 && !vis2[ney][nex])return false;



  }

  return true;

}



void dfs(int r,int c,int y,int x,int cnt,int last,int gy2,int gx2){

  if (!isok(r,c,y,x,last)){

    return;

  }

  if (!isok2(r,c,y,x,cnt))return;



  if (cnt+md >= ans)return;

  if (!bfs(r,c,cnt,true))return;



  //  if (!bfs2(r,c,cnt,gy2,gx2))return;



  /*

  for(int i=0;cnt >=5 && i<5;i++){

    cout << path[cnt-5+i]<<"" "";

  }

  cout << endl;

  vis2[y][x]=true;

  output(r,c);

  vis2[y][x]=false;

  */      



  if (x == gx2 && y == gy2){

    vis2[y][x]=true;

    bfs(r,c,cnt,false);

    vis2[y][x]=false;

    return;

  }



  vis2[y][x]=true;

  rep(i,4){

    if (op[i] == last)continue;

    int nex=x+dx[i],ney=y+dy[i];

    if (nex==-1||ney==-1||nex==c||ney==r||vis2[ney][nex])continue;

    if (m[ney][nex] == 3 || m[ney][nex] == 1)continue;

    path[cnt]=i;

    dfs(r,c,ney,nex,cnt+1,i,gy2,gx2);

  }

  vis2[y][x]=false;

}



int bfs2(int r,int c,int tar,int utar){

  static int q[N*N];

  static int cost[N][N];

  int sy3=-1,sx3=-1,gy3=-1,gx3=-1;

  rep(i,r){

    rep(j,c){

      if (m[i][j] == tar){

	if (sy3==-1)sy3=i,sx3=j;

	else gy3=i,gx3=j;

      }

      cost[i][j]=inf;

    }

  }

  int tail=0,head=0;

  q[tail++]=sx3+sy3*c;

  cost[sy3][sx3]=0;

  while(head != tail){

    int now = q[head++];

    int x = now%c,y=now/c;

    if (x == gx3 && y == gy3){

      return cost[y][x];

    }

    rep(i,4){

      int nex=x+dx[i],ney=y+dy[i];

      if (nex==-1||ney==-1||nex==c||ney==r||vis2[ney][nex])continue;

      if (m[ney][nex]==1||m[ney][nex] == utar)continue;

      if (cost[ney][nex] != inf)continue;

      cost[ney][nex]=cost[y][x]+1;

      q[tail++]=ney*c+nex;

    }

  }

  return false;

}



main(){

  int r,c;

  while(cin>>r>>c && r){

    ans = r*c;

    isgoal=false;

    rep(i,r)rep(j,c)cin>>m[i][j];

    rep(i,r)rep(j,c)vis2[i][j]=false;

   

    int sx2=-1,sy2=-1;

    int gx2=-1,gy2=-1;

    rep(i,r){

      rep(j,c){

	if (m[i][j] == 2){

	  if (sx2 == -1)sx2=j,sy2=i;

	  else gx2=j,gy2=i;

	}

      }

    }

    

    int sx3=-1,sy3=-1,gx3=-1,gy3=-1;

    rep(i,r){

      rep(j,c){

	if (m[i][j] == 3){

	  if (sx3 == -1)sx3=j,sy3=i;

	  else gx3=j,gy3=i;

	}

      }

    }



    md=bfs2(r,c,3,2);

    

    dfs(r,c,sy2,sx2,0,-1,gy2,gx2);

    

    if (isgoal)cout << ans << endl;

    else cout << 0 << endl;

  }

  return false;

}",12.71,259.0,259.0,C++,cpp
u157643087,p00849,C++,s870368250,7350.0,868.0,Accepted,"#include<iostream>

#include<algorithm>

using namespace std;

#define REP(i,b,n) for(int i=b;i<n;i++)

#define rep(i,n)   REP(i,0,n)



const int N = 9;

const int inf = (1 <<21);



int dx[]={0,1, 0,-1};

int dy[]={1,0,-1,0};

int op[]={2,3, 0,1};

int m[N][N];

bool vis2[N][N];



bool isok(int r,int c,int y,int x,int last){

  rep(i,4){

    if (op[i] == last)continue;

    int nex=x+dx[i],ney=y+dy[i];

    if (nex==-1||ney==-1||nex==c||ney==r)continue;

    if (vis2[ney][nex])return false;

  }

  return true;

}



void output(int r,int c){

  cout << ""begin""<<endl;

  rep(i,r){

    rep(j,c){

      if (vis2[i][j])cout << 2;

      else cout << '0';

    }

    cout << endl;

  }

  cout <<endl;

}





int ans;

bool isgoal;

int md;

bool bfs(int r,int c,int cnt,bool goal2){

  static int q[N*N];

  static int cost[N][N];

  int sy3=-1,sx3=-1,gy3=-1,gx3=-1;

  rep(i,r){

    rep(j,c){

      if (m[i][j] == 3){

	if (sy3==-1)sy3=i,sx3=j;

	else gy3=i,gx3=j;

      }

      cost[i][j]=inf;

    }

  }

  int tail=0,head=0;

  q[tail++]=sx3+sy3*c;

  cost[sy3][sx3]=0;

  while(head != tail){

    int now = q[head++];

    int x = now%c,y=now/c;

    if (cnt+cost[y][x] >= ans)return false;

    if (x == gx3 && y == gy3){

      if (goal2)return true;

      isgoal=true;

      ans =min(ans,cnt+cost[y][x]);

      return true;

    }

    rep(i,4){

      int nex=x+dx[i],ney=y+dy[i];

      if (nex==-1||ney==-1||nex==c||ney==r||vis2[ney][nex])continue;

      if (m[ney][nex]==1||m[ney][nex] == 2)continue;

      if (cost[ney][nex] != inf)continue;

      cost[ney][nex]=cost[y][x]+1;

      q[tail++]=ney*c+nex;

    }

  }

  return false;

}



bool bfs2(int r,int c,int cnt,int sy,int sx){

  static int q[N*N];

  static int cost[N][N];

  int sy3=-1,sx3=-1,gy3=-1,gx3=-1;

  rep(i,r){

    rep(j,c){

      if (m[i][j] == 2){

	if (sy3==-1)sy3=i,sx3=j;

	else gy3=i,gx3=j;

      }

      cost[i][j]=inf;

    }

  }

  int tail=0,head=0;

  q[tail++]=sx+sy*c;

  cost[sy][sx]=0;

  while(head != tail){

    int now = q[head++];

    int x = now%c,y=now/c;

    if (cnt+cost[y][x] >= ans)return false;

    if (x == gx3 && y == gy3){

      return true;

    }

    rep(i,4){

      int nex=x+dx[i],ney=y+dy[i];

      if (nex==-1||ney==-1||nex==c||ney==r||vis2[ney][nex])continue;

      if (m[ney][nex]==1||m[ney][nex] == 3)continue;

      if (cost[ney][nex] != inf)continue;

      cost[ney][nex]=cost[y][x]+1;

      q[tail++]=ney*c+nex;

    }

  }

  return false;

}





int path[N*N];

int pattern[8][4]={

  {2,1,1,0,},

  {1,0,0,3,},

  {0,3,3,2,},

  {3,2,2,1,},

  {2,3,3,0,},

  {1,2,2,3,},

  {0,1,1,2,},

  {3,0,0,1,},

};



int cx[]={-1, 0,1, 0, 1, 0,-1, 0};

int cy[]={ 0,-1,0, 1, 0, 1, 0,-1};



bool isok2(int r,int c,int y,int x,int p){

  if (p <4)return true;

  rep(i,8){

    bool ismatch=true;

    rep(j,4){

      if (pattern[i][j] == path[p-(4-j)]);

      else ismatch=false;

    }

    if (!ismatch)continue;

    int nex=x+cx[i],ney=y+cy[i];

    if (nex==-1||ney==-1||nex==c||ney==r)continue;

    if (m[ney][nex] == 0 && !vis2[ney][nex])return false;



  }

  return true;

}



void dfs(int r,int c,int y,int x,int cnt,int last,int gy2,int gx2){

  if (!isok(r,c,y,x,last)){

    return;

  }

  if (!isok2(r,c,y,x,cnt))return;



  if (cnt+md >= ans)return;

  if (!bfs(r,c,cnt,true))return;



  //  if (!bfs2(r,c,cnt,gy2,gx2))return;



  /*

  for(int i=0;cnt >=5 && i<5;i++){

    cout << path[cnt-5+i]<<"" "";

  }

  cout << endl;

  vis2[y][x]=true;

  output(r,c);

  vis2[y][x]=false;

  */      



  if (x == gx2 && y == gy2){

    vis2[y][x]=true;

    bfs(r,c,cnt,false);

    vis2[y][x]=false;

    return;

  }



  vis2[y][x]=true;

  rep(i,4){

    if (op[i] == last)continue;

    int nex=x+dx[i],ney=y+dy[i];

    if (nex==-1||ney==-1||nex==c||ney==r||vis2[ney][nex])continue;

    if (m[ney][nex] == 3 || m[ney][nex] == 1)continue;

    path[cnt]=i;

    dfs(r,c,ney,nex,cnt+1,i,gy2,gx2);

  }

  vis2[y][x]=false;

}



int bfs2(int r,int c,int tar,int utar){

  static int q[N*N];

  static int cost[N][N];

  int sy3=-1,sx3=-1,gy3=-1,gx3=-1;

  rep(i,r){

    rep(j,c){

      if (m[i][j] == tar){

	if (sy3==-1)sy3=i,sx3=j;

	else gy3=i,gx3=j;

      }

      cost[i][j]=inf;

    }

  }

  int tail=0,head=0;

  q[tail++]=sx3+sy3*c;

  cost[sy3][sx3]=0;

  while(head != tail){

    int now = q[head++];

    int x = now%c,y=now/c;

    if (x == gx3 && y == gy3){

      return cost[y][x];

    }

    rep(i,4){

      int nex=x+dx[i],ney=y+dy[i];

      if (nex==-1||ney==-1||nex==c||ney==r||vis2[ney][nex])continue;

      if (m[ney][nex]==1||m[ney][nex] == utar)continue;

      if (cost[ney][nex] != inf)continue;

      cost[ney][nex]=cost[y][x]+1;

      q[tail++]=ney*c+nex;

    }

  }

  return false;

}



main(){

  int r,c;

  while(cin>>r>>c && r){

    ans = r*c;

    isgoal=false;

    rep(i,r)rep(j,c)cin>>m[i][j];

    rep(i,r)rep(j,c)vis2[i][j]=false;

   

    int sx2=-1,sy2=-1;

    int gx2=-1,gy2=-1;

    rep(i,r){

      rep(j,c){

	if (m[i][j] == 2){

	  if (sx2 == -1)sx2=j,sy2=i;

	  else gx2=j,gy2=i;

	}

      }

    }

    

    int sx3=-1,sy3=-1,gx3=-1,gy3=-1;

    rep(i,r){

      rep(j,c){

	if (m[i][j] == 3){

	  if (sx3 == -1)sx3=j,sy3=i;

	  else gx3=j,gy3=i;

	}

      }

    }



    md=bfs2(r,c,3,2);

    

    dfs(r,c,sy2,sx2,0,-1,gy2,gx2);

    

    if (isgoal)cout << ans << endl;

    else cout << 0 << endl;

  }

  return false;

}",60.14,259.0,211.0,C++,cpp
u157643087,p00849,C++,s545062583,2930.0,868.0,Accepted,"#include<iostream>

#include<algorithm>

using namespace std;

#define REP(i,b,n) for(int i=b;i<n;i++)

#define rep(i,n)   REP(i,0,n)



const int N = 9;

const int inf = (1 <<21);



int dx[]={0,1, 0,-1};

int dy[]={1,0,-1,0};

int op[]={2,3, 0,1};

int m[N][N];

bool vis2[N][N];



bool isok(int r,int c,int y,int x,int last){

  rep(i,4){

    if (op[i] == last)continue;

    int nex=x+dx[i],ney=y+dy[i];

    if (nex==-1||ney==-1||nex==c||ney==r)continue;

    if (vis2[ney][nex])return false;

  }

  return true;

}



void output(int r,int c){

  cout << ""begin""<<endl;

  rep(i,r){

    rep(j,c){

      if (vis2[i][j])cout << 2;

      else cout << '0';

    }

    cout << endl;

  }

  cout <<endl;

}





int ans;

bool isgoal;

int md;

bool bfs(int r,int c,int cnt,bool goal2){

  static int q[N*N];

  static int cost[N][N];

  int sy3=-1,sx3=-1,gy3=-1,gx3=-1;

  rep(i,r){

    rep(j,c){

      if (m[i][j] == 3){

	if (sy3==-1)sy3=i,sx3=j;

	else gy3=i,gx3=j;

      }

      cost[i][j]=inf;

    }

  }

  int tail=0,head=0;

  q[tail++]=sx3+sy3*c;

  cost[sy3][sx3]=0;

  while(head != tail){

    int now = q[head++];

    int x = now%c,y=now/c;

    if (cnt+cost[y][x] >= ans)return false;

    if (x == gx3 && y == gy3){

      if (goal2)return true;

      isgoal=true;

      ans =min(ans,cnt+cost[y][x]);

      return true;

    }

    rep(i,4){

      int nex=x+dx[i],ney=y+dy[i];

      if (nex==-1||ney==-1||nex==c||ney==r||vis2[ney][nex])continue;

      if (m[ney][nex]==1||m[ney][nex] == 2)continue;

      if (cost[ney][nex] != inf)continue;

      cost[ney][nex]=cost[y][x]+1;

      q[tail++]=ney*c+nex;

    }

  }

  return false;

}



int path[N*N];

int pattern[8][4]={

  {2,1,1,0,},

  {1,0,0,3,},

  {0,3,3,2,},

  {3,2,2,1,},

  {2,3,3,0,},

  {1,2,2,3,},

  {0,1,1,2,},

  {3,0,0,1,},

};



int cx[]={-1, 0,1, 0, 1, 0,-1, 0};

int cy[]={ 0,-1,0, 1, 0, 1, 0,-1};



bool isok2(int r,int c,int y,int x,int p){

  if (p <4)return true;

  rep(i,8){

    bool ismatch=true;

    rep(j,4){

      if (pattern[i][j] == path[p-(4-j)]);

      else ismatch=false;

    }

    if (!ismatch)continue;

    int nex=x+cx[i],ney=y+cy[i];

    if (nex==-1||ney==-1||nex==c||ney==r)continue;

    if (m[ney][nex] == 0 && !vis2[ney][nex])return false;



  }

  return true;

}



void dfs(int r,int c,int y,int x,int cnt,int last,int gy2,int gx2){

  if (!isok(r,c,y,x,last)){

    return;

  }

  if (!isok2(r,c,y,x,cnt))return;



  if (cnt+md >= ans)return;

  //  if (!bfs(r,c,cnt,true))return;



  if (x == gx2 && y == gy2){

    vis2[y][x]=true;

    bfs(r,c,cnt,false);

    vis2[y][x]=false;

    return;

  }



  vis2[y][x]=true;

  rep(i,4){

    if (op[i] == last)continue;

    int nex=x+dx[i],ney=y+dy[i];

    if (nex==-1||ney==-1||nex==c||ney==r||vis2[ney][nex])continue;

    if (m[ney][nex] == 3 || m[ney][nex] == 1)continue;

    path[cnt]=i;

    dfs(r,c,ney,nex,cnt+1,i,gy2,gx2);

  }

  vis2[y][x]=false;

}



int bfs2(int r,int c,int tar,int utar){

  static int q[N*N];

  static int cost[N][N];

  int sy3=-1,sx3=-1,gy3=-1,gx3=-1;

  rep(i,r){

    rep(j,c){

      if (m[i][j] == tar){

	if (sy3==-1)sy3=i,sx3=j;

	else gy3=i,gx3=j;

      }

      cost[i][j]=inf;

    }

  }

  int tail=0,head=0;

  q[tail++]=sx3+sy3*c;

  cost[sy3][sx3]=0;

  while(head != tail){

    int now = q[head++];

    int x = now%c,y=now/c;

    if (x == gx3 && y == gy3){

      return cost[y][x];

    }

    rep(i,4){

      int nex=x+dx[i],ney=y+dy[i];

      if (nex==-1||ney==-1||nex==c||ney==r||vis2[ney][nex])continue;

      if (m[ney][nex]==1||m[ney][nex] == utar)continue;

      if (cost[ney][nex] != inf)continue;

      cost[ney][nex]=cost[y][x]+1;

      q[tail++]=ney*c+nex;

    }

  }

  return false;

}



main(){

  int r,c;

  while(cin>>r>>c && r){

    ans = r*c;

    isgoal=false;

    rep(i,r)rep(j,c)cin>>m[i][j];

    rep(i,r)rep(j,c)vis2[i][j]=false;

   

    int sx2=-1,sy2=-1;

    int gx2=-1,gy2=-1;

    rep(i,r){

      rep(j,c){

	if (m[i][j] == 2){

	  if (sx2 == -1)sx2=j,sy2=i;

	  else gx2=j,gy2=i;

	}

      }

    }

    

    int sx3=-1,sy3=-1,gx3=-1,gy3=-1;

    rep(i,r){

      rep(j,c){

	if (m[i][j] == 3){

	  if (sx3 == -1)sx3=j,sy3=i;

	  else gx3=j,gy3=i;

	}

      }

    }



    md=bfs2(r,c,3,2);

    

    dfs(r,c,sy2,sx2,0,-1,gy2,gx2);

    

    if (isgoal)cout << ans << endl;

    else cout << 0 << endl;

  }

  return false;

}",60.14,259.0,211.0,C++,cpp
u157643087,p00849,C++,s476552923,2930.0,872.0,Accepted,"#include<iostream>

#include<algorithm>

using namespace std;

#define REP(i,b,n) for(int i=b;i<n;i++)

#define rep(i,n)   REP(i,0,n)



const int N = 9;

const int inf = (1 <<21);



int dx[]={0,1, 0,-1};

int dy[]={1,0,-1,0};

int op[]={2,3, 0,1};

int m[N][N];

bool vis2[N][N];



bool isok(int r,int c,int y,int x,int last){

  rep(i,4){

    if (op[i] == last)continue;

    int nex=x+dx[i],ney=y+dy[i];

    if (nex==-1||ney==-1||nex==c||ney==r)continue;

    if (vis2[ney][nex])return false;

  }

  return true;

}



void output(int r,int c){

  cout << ""begin""<<endl;

  rep(i,r){

    rep(j,c){

      if (vis2[i][j])cout << 2;

      else cout << '0';

    }

    cout << endl;

  }

  cout <<endl;

}





int ans;

bool isgoal;

int md;

bool bfs(int r,int c,int cnt,bool goal2){

  static int q[N*N];

  static int cost[N][N];

  int sy3=-1,sx3=-1,gy3=-1,gx3=-1;

  rep(i,r){

    rep(j,c){

      if (m[i][j] == 3){

	if (sy3==-1)sy3=i,sx3=j;

	else gy3=i,gx3=j;

      }

      cost[i][j]=inf;

    }

  }

  int tail=0,head=0;

  q[tail++]=sx3+sy3*c;

  cost[sy3][sx3]=0;

  while(head != tail){

    int now = q[head++];

    int x = now%c,y=now/c;

    if (cnt+cost[y][x] >= ans)return false;

    if (x == gx3 && y == gy3){

      if (goal2)return true;

      isgoal=true;

      ans =min(ans,cnt+cost[y][x]);

      return true;

    }

    rep(i,4){

      int nex=x+dx[i],ney=y+dy[i];

      if (nex==-1||ney==-1||nex==c||ney==r||vis2[ney][nex])continue;

      if (m[ney][nex]==1||m[ney][nex] == 2)continue;

      if (cost[ney][nex] != inf)continue;

      cost[ney][nex]=cost[y][x]+1;

      q[tail++]=ney*c+nex;

    }

  }

  return false;

}



int path[N*N];

int pattern[8][4]={

  {2,1,1,0,},

  {1,0,0,3,},

  {0,3,3,2,},

  {3,2,2,1,},

  {2,3,3,0,},

  {1,2,2,3,},

  {0,1,1,2,},

  {3,0,0,1,},

};



int cx[]={-1, 0,1, 0, 1, 0,-1, 0};

int cy[]={ 0,-1,0, 1, 0, 1, 0,-1};



bool isok2(int r,int c,int y,int x,int p){

  if (p <4)return true;

  rep(i,8){

    bool ismatch=true;

    rep(j,4){

      if (pattern[i][j] == path[p-(4-j)]);

      else ismatch=false;

    }

    if (!ismatch)continue;

    int nex=x+cx[i],ney=y+cy[i];

    if (nex==-1||ney==-1||nex==c||ney==r)continue;

    if (m[ney][nex] == 0 && !vis2[ney][nex])return false;



  }

  return true;

}



void dfs(int r,int c,int y,int x,int cnt,int last,int gy2,int gx2){

  if (!isok(r,c,y,x,last)){

    return;

  }

  if (!isok2(r,c,y,x,cnt))return;



  if (cnt+md >= ans)return;

  //  if (!bfs(r,c,cnt,true))return;



  if (x == gx2 && y == gy2){

    vis2[y][x]=true;

    bfs(r,c,cnt,false);

    vis2[y][x]=false;

    return;

  }



  vis2[y][x]=true;

  rep(i,4){

    if (op[i] == last)continue;

    int nex=x+dx[i],ney=y+dy[i];

    if (nex==-1||ney==-1||nex==c||ney==r||vis2[ney][nex])continue;

    if (m[ney][nex] == 3 || m[ney][nex] == 1)continue;

    path[cnt]=i;

    dfs(r,c,ney,nex,cnt+1,i,gy2,gx2);

  }

  vis2[y][x]=false;

}



int bfs2(int r,int c,int tar,int utar){

  static int q[N*N];

  static int cost[N][N];

  int sy3=-1,sx3=-1,gy3=-1,gx3=-1;

  rep(i,r){

    rep(j,c){

      if (m[i][j] == tar){

	if (sy3==-1)sy3=i,sx3=j;

	else gy3=i,gx3=j;

      }

      cost[i][j]=inf;

    }

  }

  int tail=0,head=0;

  q[tail++]=sx3+sy3*c;

  cost[sy3][sx3]=0;

  while(head != tail){

    int now = q[head++];

    int x = now%c,y=now/c;

    if (x == gx3 && y == gy3){

      return cost[y][x];

    }

    rep(i,4){

      int nex=x+dx[i],ney=y+dy[i];

      if (nex==-1||ney==-1||nex==c||ney==r||vis2[ney][nex])continue;

      if (m[ney][nex]==1||m[ney][nex] == utar)continue;

      if (cost[ney][nex] != inf)continue;

      cost[ney][nex]=cost[y][x]+1;

      q[tail++]=ney*c+nex;

    }

  }

  return false;

}



main(){

  int r,c;

  while(cin>>r>>c && r){

    ans = r*c;

    isgoal=false;

    rep(i,r)rep(j,c)cin>>m[i][j];

    rep(i,r)rep(j,c)vis2[i][j]=false;

   

    int sx2=-1,sy2=-1;

    int gx2=-1,gy2=-1;

    rep(i,r){

      rep(j,c){

	if (m[i][j] == 2){

	  if (sx2 == -1)sx2=j,sy2=i;

	  else gx2=j,gy2=i;

	}

      }

    }

    

    int sx3=-1,sy3=-1,gx3=-1,gy3=-1;

    rep(i,r){

      rep(j,c){

	if (m[i][j] == 3){

	  if (sx3 == -1)sx3=j,sy3=i;

	  else gx3=j,gy3=i;

	}

      }

    }



    md=bfs2(r,c,3,2);

    

    dfs(r,c,sy2,sx2,0,-1,gy2,gx2);

    

    if (isgoal)cout << ans << endl;

    else cout << 0 << endl;

  }

  return false;

}",2.73,211.0,198.0,C++,cpp
u157643087,p00849,C++,s019272801,2850.0,872.0,Accepted,"#include<iostream>

#include<algorithm>

using namespace std;

#define REP(i,b,n) for(int i=b;i<n;i++)

#define rep(i,n)   REP(i,0,n)



const int N = 9;

const int inf = (1 <<21);



int dx[]={0,1, 0,-1};

int dy[]={1,0,-1,0};

int op[]={2,3, 0,1};

int m[N][N];

bool vis2[N][N];



bool isok(int r,int c,int y,int x,int last){

  rep(i,4){

    if (op[i] == last)continue;

    int nex=x+dx[i],ney=y+dy[i];

    if (nex==-1||ney==-1||nex==c||ney==r)continue;

    if (vis2[ney][nex])return false;

  }

  return true;

}



int ans;

bool isgoal;

int md;

bool bfs(int r,int c,int cnt,bool goal2){

  static int q[N*N];

  static int cost[N][N];

  int sy3=-1,sx3=-1,gy3=-1,gx3=-1;

  rep(i,r){

    rep(j,c){

      if (m[i][j] == 3){

	if (sy3==-1)sy3=i,sx3=j;

	else gy3=i,gx3=j;

      }

      cost[i][j]=inf;

    }

  }

  int tail=0,head=0;

  q[tail++]=sx3+sy3*c;

  cost[sy3][sx3]=0;

  while(head != tail){

    int now = q[head++];

    int x = now%c,y=now/c;

    if (cnt+cost[y][x] >= ans)return false;

    if (x == gx3 && y == gy3){

      if (goal2)return true;

      isgoal=true;

      ans =min(ans,cnt+cost[y][x]);

      return true;

    }

    rep(i,4){

      int nex=x+dx[i],ney=y+dy[i];

      if (nex==-1||ney==-1||nex==c||ney==r||vis2[ney][nex])continue;

      if (m[ney][nex]==1||m[ney][nex] == 2)continue;

      if (cost[ney][nex] != inf)continue;

      cost[ney][nex]=cost[y][x]+1;

      q[tail++]=ney*c+nex;

    }

  }

  return false;

}



int path[N*N];

int pattern[8][4]={

  {2,1,1,0,},

  {1,0,0,3,},

  {0,3,3,2,},

  {3,2,2,1,},

  {2,3,3,0,},

  {1,2,2,3,},

  {0,1,1,2,},

  {3,0,0,1,},

};



int cx[]={-1, 0,1, 0, 1, 0,-1, 0};

int cy[]={ 0,-1,0, 1, 0, 1, 0,-1};



bool isok2(int r,int c,int y,int x,int p){

  if (p <4)return true;

  rep(i,8){

    bool ismatch=true;

    rep(j,4){

      if (pattern[i][j] == path[p-(4-j)]);

      else ismatch=false;

    }

    if (!ismatch)continue;

    int nex=x+cx[i],ney=y+cy[i];

    if (nex==-1||ney==-1||nex==c||ney==r)continue;

    if (m[ney][nex] == 0 && !vis2[ney][nex])return false;



  }

  return true;

}



void dfs(int r,int c,int y,int x,int cnt,int last,int gy2,int gx2){

  if (!isok(r,c,y,x,last)){

    return;

  }

  if (!isok2(r,c,y,x,cnt))return;



  if (cnt+md >= ans)return;

  //  if (!bfs(r,c,cnt,true))return;



  if (x == gx2 && y == gy2){

    vis2[y][x]=true;

    bfs(r,c,cnt,false);

    vis2[y][x]=false;

    return;

  }



  vis2[y][x]=true;

  rep(i,4){

    if (op[i] == last)continue;

    int nex=x+dx[i],ney=y+dy[i];

    if (nex==-1||ney==-1||nex==c||ney==r||vis2[ney][nex])continue;

    if (m[ney][nex] == 3 || m[ney][nex] == 1)continue;

    path[cnt]=i;

    dfs(r,c,ney,nex,cnt+1,i,gy2,gx2);

  }

  vis2[y][x]=false;

}



int bfs2(int r,int c,int tar,int utar){

  static int q[N*N];

  static int cost[N][N];

  int sy3=-1,sx3=-1,gy3=-1,gx3=-1;

  rep(i,r){

    rep(j,c){

      if (m[i][j] == tar){

	if (sy3==-1)sy3=i,sx3=j;

	else gy3=i,gx3=j;

      }

      cost[i][j]=inf;

    }

  }

  int tail=0,head=0;

  q[tail++]=sx3+sy3*c;

  cost[sy3][sx3]=0;

  while(head != tail){

    int now = q[head++];

    int x = now%c,y=now/c;

    if (x == gx3 && y == gy3){

      return cost[y][x];

    }

    rep(i,4){

      int nex=x+dx[i],ney=y+dy[i];

      if (nex==-1||ney==-1||nex==c||ney==r||vis2[ney][nex])continue;

      if (m[ney][nex]==1||m[ney][nex] == utar)continue;

      if (cost[ney][nex] != inf)continue;

      cost[ney][nex]=cost[y][x]+1;

      q[tail++]=ney*c+nex;

    }

  }

  return false;

}



main(){

  int r,c;

  while(cin>>r>>c && r){

    ans = r*c;

    isgoal=false;

    rep(i,r)rep(j,c)cin>>m[i][j];

    rep(i,r)rep(j,c)vis2[i][j]=false;

   

    int sx2=-1,sy2=-1;

    int gx2=-1,gy2=-1;

    rep(i,r){

      rep(j,c){

	if (m[i][j] == 2){

	  if (sx2 == -1)sx2=j,sy2=i;

	  else gx2=j,gy2=i;

	}

      }

    }

    

    int sx3=-1,sy3=-1,gx3=-1,gy3=-1;

    rep(i,r){

      rep(j,c){

	if (m[i][j] == 3){

	  if (sx3 == -1)sx3=j,sy3=i;

	  else gx3=j,gy3=i;

	}

      }

    }



    md=bfs2(r,c,3,2);

    

    dfs(r,c,sy2,sx2,0,-1,gy2,gx2);

    

    if (isgoal)cout << ans << endl;

    else cout << 0 << endl;

  }

  return false;

}",2.73,211.0,198.0,C++,cpp
u157859087,p00849,C++,s120017380,2840.0,1028.0,Accepted,"#include<cstdio>

#include<cstring>

#include<sys/time.h>



#define rep(i,n) for(int i=0;i<(n);i++)



using namespace std;



typedef long long ll;



ll gettime(){

	struct timeval tv;

	gettimeofday(&tv,NULL);

	return 1000000LL*tv.tv_sec+tv.tv_usec;

}



const int dx[]={1,0,-1,0},dy[]={0,-1,0,1};



int h,w,B[9][9];



int x2,y2,x3,y3; // 2, 3 それぞれの出発点



int bfs(int x,int y,int tar){

	int d[9][9];

	memset(d,-1,sizeof d);

	d[y][x]=0;

	int Q[81],head=0,tail=0; Q[tail++]=y*w+x;

	while(head<tail){

		int i=Q[head]/w,j=Q[head]%w; head++;

		rep(k,4){

			int yy=i+dy[k],xx=j+dx[k];

			if(0<=yy && yy<h && 0<=xx && xx<w && d[yy][xx]==-1){

				if(B[yy][xx]==tar) return d[i][j]+1;

				if(B[yy][xx]== 0 ) Q[tail++]=yy*w+xx, d[yy][xx]=d[i][j]+1;

			}

		}

	}

	return 777;

}



ll t0;



int ans;

void dfs(int x,int y,int now){

	int hstar=bfs(x,y,2)+bfs(x3,y3,3);

	if(ans<now+1+hstar) return;



	if(ans==777){ // 3 秒の間に一つも解が見つからなければ解なし

		ll t1=gettime();

		if(t1-t0>3000000){ ans=0; return; }

	}



	// これまでのパスと接したら最適解でないので探索打ち切り

	int cnt=0;

	rep(k,4){

		int xx=x+dx[k],yy=y+dy[k];

		if(0<=xx && xx<w && 0<=yy && yy<h && B[yy][xx]==7) cnt++;

	}

	if(cnt>=2) return;



	rep(k,4){

		int xx=x+dx[k],yy=y+dy[k];

		if(0<=xx && xx<w && 0<=yy && yy<h){

			if(B[yy][xx]==2){

				ans=now+1+bfs(x3,y3,3);

				return;

			}

			else if(B[yy][xx]==0){

				B[yy][xx]=7;

				dfs(xx,yy,now+1);

				B[yy][xx]=0;

			}

		}

	}

}



int main(){

	while(scanf(""%d%d"",&h,&w),h){

		rep(i,h) rep(j,w) scanf(""%d"",B[i]+j);



		rep(i,h) rep(j,w) {

			if(B[i][j]==2) x2=j, y2=i;

			if(B[i][j]==3) x3=j, y3=i;

		}

		B[y2][x2]=7; // 訪問済みのマーク



		t0=gettime();

		ans=777;

		dfs(x2,y2,0);

		printf(""%d\n"",ans<777?ans:0);

	}



	return 0;

}",18.31,94.0,94.0,C++,cpp
u157859087,p00849,C++,s268900973,2320.0,1028.0,Accepted,"#include<cstdio>

#include<cstring>

#include<sys/time.h>



#define rep(i,n) for(int i=0;i<(n);i++)



using namespace std;



typedef long long ll;



ll gettime(){

	struct timeval tv;

	gettimeofday(&tv,NULL);

	return 1000000LL*tv.tv_sec+tv.tv_usec;

}



const int dx[]={1,0,-1,0},dy[]={0,-1,0,1};



int h,w,B[9][9];



int x2,y2,x3,y3; // 2, 3 それぞれの出発点



int bfs(int x,int y,int tar){

	int d[9][9];

	memset(d,-1,sizeof d);

	d[y][x]=0;

	int Q[81],head=0,tail=0; Q[tail++]=y*w+x;

	while(head<tail){

		int i=Q[head]/w,j=Q[head]%w; head++;

		rep(k,4){

			int yy=i+dy[k],xx=j+dx[k];

			if(0<=yy && yy<h && 0<=xx && xx<w && d[yy][xx]==-1){

				if(B[yy][xx]==tar) return d[i][j]+1;

				if(B[yy][xx]== 0 ) Q[tail++]=yy*w+xx, d[yy][xx]=d[i][j]+1;

			}

		}

	}

	return 777;

}



ll t0;



int ans;

void dfs(int x,int y,int now){

	int hstar=bfs(x,y,2)+bfs(x3,y3,3);

	if(ans<now+1+hstar) return;



	if(ans==777){ // 1 秒の間に一つも解が見つからなければ解なし

		ll t1=gettime();

		if(t1-t0>1000000){ ans=0; return; }

	}



	// これまでのパスと接したら最適解でないので探索打ち切り

	int cnt=0;

	rep(k,4){

		int xx=x+dx[k],yy=y+dy[k];

		if(0<=xx && xx<w && 0<=yy && yy<h && B[yy][xx]==7) cnt++;

	}

	if(cnt>=2) return;



	rep(k,4){

		int xx=x+dx[k],yy=y+dy[k];

		if(0<=xx && xx<w && 0<=yy && yy<h){

			if(B[yy][xx]==2){

				ans=now+1+bfs(x3,y3,3);

				return;

			}

			else if(B[yy][xx]==0){

				B[yy][xx]=7;

				dfs(xx,yy,now+1);

				B[yy][xx]=0;

			}

		}

	}

}



int main(){

	while(scanf(""%d%d"",&h,&w),h){

		rep(i,h) rep(j,w) scanf(""%d"",B[i]+j);



		rep(i,h) rep(j,w) {

			if(B[i][j]==2) x2=j, y2=i;

			if(B[i][j]==3) x3=j, y3=i;

		}

		B[y2][x2]=7; // 訪問済みのマーク



		t0=gettime();

		ans=777;

		dfs(x2,y2,0);

		printf(""%d\n"",ans<777?ans:0);

	}



	return 0;

}",18.31,94.0,94.0,C++,cpp
u157859087,p00849,C++,s268900973,2320.0,1028.0,Accepted,"#include<cstdio>

#include<cstring>

#include<sys/time.h>



#define rep(i,n) for(int i=0;i<(n);i++)



using namespace std;



typedef long long ll;



ll gettime(){

	struct timeval tv;

	gettimeofday(&tv,NULL);

	return 1000000LL*tv.tv_sec+tv.tv_usec;

}



const int dx[]={1,0,-1,0},dy[]={0,-1,0,1};



int h,w,B[9][9];



int x2,y2,x3,y3; // 2, 3 それぞれの出発点



int bfs(int x,int y,int tar){

	int d[9][9];

	memset(d,-1,sizeof d);

	d[y][x]=0;

	int Q[81],head=0,tail=0; Q[tail++]=y*w+x;

	while(head<tail){

		int i=Q[head]/w,j=Q[head]%w; head++;

		rep(k,4){

			int yy=i+dy[k],xx=j+dx[k];

			if(0<=yy && yy<h && 0<=xx && xx<w && d[yy][xx]==-1){

				if(B[yy][xx]==tar) return d[i][j]+1;

				if(B[yy][xx]== 0 ) Q[tail++]=yy*w+xx, d[yy][xx]=d[i][j]+1;

			}

		}

	}

	return 777;

}



ll t0;



int ans;

void dfs(int x,int y,int now){

	int hstar=bfs(x,y,2)+bfs(x3,y3,3);

	if(ans<now+1+hstar) return;



	if(ans==777){ // 1 秒の間に一つも解が見つからなければ解なし

		ll t1=gettime();

		if(t1-t0>1000000){ ans=0; return; }

	}



	// これまでのパスと接したら最適解でないので探索打ち切り

	int cnt=0;

	rep(k,4){

		int xx=x+dx[k],yy=y+dy[k];

		if(0<=xx && xx<w && 0<=yy && yy<h && B[yy][xx]==7) cnt++;

	}

	if(cnt>=2) return;



	rep(k,4){

		int xx=x+dx[k],yy=y+dy[k];

		if(0<=xx && xx<w && 0<=yy && yy<h){

			if(B[yy][xx]==2){

				ans=now+1+bfs(x3,y3,3);

				return;

			}

			else if(B[yy][xx]==0){

				B[yy][xx]=7;

				dfs(xx,yy,now+1);

				B[yy][xx]=0;

			}

		}

	}

}



int main(){

	while(scanf(""%d%d"",&h,&w),h){

		rep(i,h) rep(j,w) scanf(""%d"",B[i]+j);



		rep(i,h) rep(j,w) {

			if(B[i][j]==2) x2=j, y2=i;

			if(B[i][j]==3) x3=j, y3=i;

		}

		B[y2][x2]=7; // 訪問済みのマーク



		t0=gettime();

		ans=777;

		dfs(x2,y2,0);

		printf(""%d\n"",ans<777?ans:0);

	}



	return 0;

}",21.55,94.0,94.0,C++,cpp
u157859087,p00849,C++,s068336570,1820.0,1028.0,Accepted,"#include<cstdio>

#include<cstring>

#include<sys/time.h>



#define rep(i,n) for(int i=0;i<(n);i++)



using namespace std;



typedef long long ll;



ll gettime(){

	struct timeval tv;

	gettimeofday(&tv,NULL);

	return 1000000LL*tv.tv_sec+tv.tv_usec;

}



const int dx[]={1,0,-1,0},dy[]={0,-1,0,1};



int h,w,B[9][9];



int x2,y2,x3,y3; // 2, 3 それぞれの出発点



int bfs(int x,int y,int tar){

	int d[9][9];

	memset(d,-1,sizeof d);

	d[y][x]=0;

	int Q[81],head=0,tail=0; Q[tail++]=y*w+x;

	while(head<tail){

		int i=Q[head]/w,j=Q[head]%w; head++;

		rep(k,4){

			int yy=i+dy[k],xx=j+dx[k];

			if(0<=yy && yy<h && 0<=xx && xx<w && d[yy][xx]==-1){

				if(B[yy][xx]==tar) return d[i][j]+1;

				if(B[yy][xx]== 0 ) Q[tail++]=yy*w+xx, d[yy][xx]=d[i][j]+1;

			}

		}

	}

	return 777;

}



ll t0;



int ans;

void dfs(int x,int y,int now){

	int hstar=bfs(x,y,2)+bfs(x3,y3,3);

	if(ans<now+1+hstar) return;



	if(ans==777){ // 0.5 秒の間に一つも解が見つからなければ解なし

		ll t1=gettime();

		if(t1-t0>500000){ ans=0; return; }

	}



	// これまでのパスと接したら最適解でないので探索打ち切り

	int cnt=0;

	rep(k,4){

		int xx=x+dx[k],yy=y+dy[k];

		if(0<=xx && xx<w && 0<=yy && yy<h && B[yy][xx]==7) cnt++;

	}

	if(cnt>=2) return;



	rep(k,4){

		int xx=x+dx[k],yy=y+dy[k];

		if(0<=xx && xx<w && 0<=yy && yy<h){

			if(B[yy][xx]==2){

				ans=now+1+bfs(x3,y3,3);

				return;

			}

			else if(B[yy][xx]==0){

				B[yy][xx]=7;

				dfs(xx,yy,now+1);

				B[yy][xx]=0;

			}

		}

	}

}



int main(){

	while(scanf(""%d%d"",&h,&w),h){

		rep(i,h) rep(j,w) scanf(""%d"",B[i]+j);



		rep(i,h) rep(j,w) {

			if(B[i][j]==2) x2=j, y2=i;

			if(B[i][j]==3) x3=j, y3=i;

		}

		B[y2][x2]=7; // 訪問済みのマーク



		t0=gettime();

		ans=777;

		dfs(x2,y2,0);

		printf(""%d\n"",ans<777?ans:0);

	}



	return 0;

}",21.55,94.0,94.0,C++,cpp
u157859087,p00849,C++,s068336570,1820.0,1028.0,Accepted,"#include<cstdio>

#include<cstring>

#include<sys/time.h>



#define rep(i,n) for(int i=0;i<(n);i++)



using namespace std;



typedef long long ll;



ll gettime(){

	struct timeval tv;

	gettimeofday(&tv,NULL);

	return 1000000LL*tv.tv_sec+tv.tv_usec;

}



const int dx[]={1,0,-1,0},dy[]={0,-1,0,1};



int h,w,B[9][9];



int x2,y2,x3,y3; // 2, 3 それぞれの出発点



int bfs(int x,int y,int tar){

	int d[9][9];

	memset(d,-1,sizeof d);

	d[y][x]=0;

	int Q[81],head=0,tail=0; Q[tail++]=y*w+x;

	while(head<tail){

		int i=Q[head]/w,j=Q[head]%w; head++;

		rep(k,4){

			int yy=i+dy[k],xx=j+dx[k];

			if(0<=yy && yy<h && 0<=xx && xx<w && d[yy][xx]==-1){

				if(B[yy][xx]==tar) return d[i][j]+1;

				if(B[yy][xx]== 0 ) Q[tail++]=yy*w+xx, d[yy][xx]=d[i][j]+1;

			}

		}

	}

	return 777;

}



ll t0;



int ans;

void dfs(int x,int y,int now){

	int hstar=bfs(x,y,2)+bfs(x3,y3,3);

	if(ans<now+1+hstar) return;



	if(ans==777){ // 0.5 秒の間に一つも解が見つからなければ解なし

		ll t1=gettime();

		if(t1-t0>500000){ ans=0; return; }

	}



	// これまでのパスと接したら最適解でないので探索打ち切り

	int cnt=0;

	rep(k,4){

		int xx=x+dx[k],yy=y+dy[k];

		if(0<=xx && xx<w && 0<=yy && yy<h && B[yy][xx]==7) cnt++;

	}

	if(cnt>=2) return;



	rep(k,4){

		int xx=x+dx[k],yy=y+dy[k];

		if(0<=xx && xx<w && 0<=yy && yy<h){

			if(B[yy][xx]==2){

				ans=now+1+bfs(x3,y3,3);

				return;

			}

			else if(B[yy][xx]==0){

				B[yy][xx]=7;

				dfs(xx,yy,now+1);

				B[yy][xx]=0;

			}

		}

	}

}



int main(){

	while(scanf(""%d%d"",&h,&w),h){

		rep(i,h) rep(j,w) scanf(""%d"",B[i]+j);



		rep(i,h) rep(j,w) {

			if(B[i][j]==2) x2=j, y2=i;

			if(B[i][j]==3) x3=j, y3=i;

		}

		B[y2][x2]=7; // 訪問済みのマーク



		t0=gettime();

		ans=777;

		dfs(x2,y2,0);

		printf(""%d\n"",ans<777?ans:0);

	}



	return 0;

}",25.82,94.0,136.0,C++,cpp
u157859087,p00849,C++,s915179304,1350.0,1036.0,Accepted,"#include<cstdio>

#include<cstring>



#define rep(i,n) for(int i=0;i<(n);i++)



using namespace std;



const int dx[]={1,0,-1,0},dy[]={0,-1,0,1};



int h,w,B[9][9];



int x2,y2,x3,y3; // 2, 3 それぞれの出発点



int bfs(int x,int y,int tar){

	int d[9][9];

	memset(d,-1,sizeof d);

	d[y][x]=0;

	int Q[81],head=0,tail=0; Q[tail++]=y*w+x;

	while(head<tail){

		int i=Q[head]/w,j=Q[head]%w; head++;

		rep(k,4){

			int yy=i+dy[k],xx=j+dx[k];

			if(0<=yy && yy<h && 0<=xx && xx<w && d[yy][xx]==-1){

				if(B[yy][xx]==tar) return d[i][j]+1;

				if(B[yy][xx]== 0 ) Q[tail++]=yy*w+xx, d[yy][xx]=d[i][j]+1;

			}

		}

	}

	return 777;

}



int ans;

void dfs(int x,int y,int now){

	int hstar=bfs(x,y,2)+bfs(x3,y3,3);

	if(ans<now+1+hstar) return;



	// これまでのパスと接したら枝刈り

	int cnt=0;

	rep(k,4){

		int xx=x+dx[k],yy=y+dy[k];

		if(0<=xx && xx<w && 0<=yy && yy<h && B[yy][xx]==7) cnt++;

	}

	if(cnt>=2) return;



	// 777...777

	// 700...007

	// というパターン ( or 回転して一致するもの ) があれば枝刈り

	for(int L=3;L<=8;L++){

		bool ng;

		if(y>0 && x+L-1<w){

			ng=true;

			if(ng) rep(j,L) if(B[y-1][x+j]!=7) { ng=false; break; }

			if(ng) rep(j,L) if(B[y  ][x+j]!=(j==0||j==L-1?7:0)) { ng=false; break; }

			if(ng && y+1<h) rep(j,L) if(0<j && j<L-1 && B[y+1][x+j]!=0) { ng=false; break; }

			if(ng) return;



			ng=true;

			if(ng && y-2>=0) rep(j,L) if(0<j && j<L-1 && B[y-2][x+j]!=0) { ng=false; break; }

			if(ng) rep(j,L) if(B[y-1][x+j]!=(j==0||j==L-1?7:0)) { ng=false; break; }

			if(ng) rep(j,L) if(B[y  ][x+j]!=7) { ng=false; break; }

			if(ng) return;

		}

		if(y>0 && x-L+1>=0){

			ng=true;

			if(ng) rep(j,L) if(B[y-1][x-j]!=7) { ng=false; break; }

			if(ng) rep(j,L) if(B[y  ][x-j]!=(j==0||j==L-1?7:0)) { ng=false; break; }

			if(ng && y+1<h) rep(j,L) if(0<j && j<L-1 && B[y+1][x-j]!=0) { ng=false; break; }

			if(ng) return;



			ng=true;

			if(ng && y-2>=0) rep(j,L) if(0<j && j<L-1 && B[y-2][x-j]!=0) { ng=false; break; }

			if(ng) rep(j,L) if(B[y-1][x-j]!=(j==0||j==L-1?7:0)) { ng=false; break; }

			if(ng) rep(j,L) if(B[y  ][x-j]!=7) { ng=false; break; }

			if(ng) return;

		}

		if(y+L-1<h && x+1<w){

			ng=true;

			if(ng) rep(i,L) if(B[y+i][x  ]!=7) { ng=false; break; }

			if(ng) rep(i,L) if(B[y+i][x+1]!=(i==0||i==L-1?7:0)) { ng=false; break; }

			if(ng && x+2<w) rep(i,L) if(0<i && i<L-1 && B[y+i][x+2]!=0) { ng=false; break; }

			if(ng) return;



			ng=true;

			if(ng && x-1>=0) rep(i,L) if(0<i && i<L-1 && B[y+i][x-1]!=0) { ng=false; break; }

			if(ng) rep(i,L) if(B[y+i][x  ]!=(i==0||i==L-1?7:0)) { ng=false; break; }

			if(ng) rep(i,L) if(B[y+i][x+1]!=7) { ng=false; break; }

			if(ng) return;

		}

		if(y-L+1>=0 && x+1<w){

			ng=true;

			if(ng) rep(i,L) if(B[y-i][x  ]!=7) { ng=false; break; }

			if(ng) rep(i,L) if(B[y-i][x+1]!=(i==0||i==L-1?7:0)) { ng=false; break; }

			if(ng && x+2<w) rep(i,L) if(0<i && i<L-1 && B[y-i][x+2]!=0) { ng=false; break; }

			if(ng) return;



			ng=true;

			if(ng && x-1>=0) rep(i,L) if(0<i && i<L-1 && B[y-i][x-1]!=0) { ng=false; break; }

			if(ng) rep(i,L) if(B[y-i][x  ]!=(i==0||i==L-1?7:0)) { ng=false; break; }

			if(ng) rep(i,L) if(B[y-i][x+1]!=7) { ng=false; break; }

			if(ng) return;

		}

	}



	rep(k,4){

		int xx=x+dx[k],yy=y+dy[k];

		if(0<=xx && xx<w && 0<=yy && yy<h){

			if(B[yy][xx]==2){

				ans=now+1+bfs(x3,y3,3);

				return;

			}

			else if(B[yy][xx]==0){

				B[yy][xx]=7;

				dfs(xx,yy,now+1);

				B[yy][xx]=0;

			}

		}

	}

}



int main(){

	while(scanf(""%d%d"",&h,&w),h){

		rep(i,h) rep(j,w) scanf(""%d"",B[i]+j);



		rep(i,h) rep(j,w) {

			if(B[i][j]==2) x2=j, y2=i;

			if(B[i][j]==3) x3=j, y3=i;

		}

		B[y2][x2]=7; // 訪問済みのマーク



		ans=777;

		dfs(x2,y2,0);

		printf(""%d\n"",ans<777?ans:0);

	}



	return 0;

}",25.82,94.0,136.0,C++,cpp
u157859087,p00849,C++,s915179304,1350.0,1036.0,Accepted,"#include<cstdio>

#include<cstring>



#define rep(i,n) for(int i=0;i<(n);i++)



using namespace std;



const int dx[]={1,0,-1,0},dy[]={0,-1,0,1};



int h,w,B[9][9];



int x2,y2,x3,y3; // 2, 3 それぞれの出発点



int bfs(int x,int y,int tar){

	int d[9][9];

	memset(d,-1,sizeof d);

	d[y][x]=0;

	int Q[81],head=0,tail=0; Q[tail++]=y*w+x;

	while(head<tail){

		int i=Q[head]/w,j=Q[head]%w; head++;

		rep(k,4){

			int yy=i+dy[k],xx=j+dx[k];

			if(0<=yy && yy<h && 0<=xx && xx<w && d[yy][xx]==-1){

				if(B[yy][xx]==tar) return d[i][j]+1;

				if(B[yy][xx]== 0 ) Q[tail++]=yy*w+xx, d[yy][xx]=d[i][j]+1;

			}

		}

	}

	return 777;

}



int ans;

void dfs(int x,int y,int now){

	int hstar=bfs(x,y,2)+bfs(x3,y3,3);

	if(ans<now+1+hstar) return;



	// これまでのパスと接したら枝刈り

	int cnt=0;

	rep(k,4){

		int xx=x+dx[k],yy=y+dy[k];

		if(0<=xx && xx<w && 0<=yy && yy<h && B[yy][xx]==7) cnt++;

	}

	if(cnt>=2) return;



	// 777...777

	// 700...007

	// というパターン ( or 回転して一致するもの ) があれば枝刈り

	for(int L=3;L<=8;L++){

		bool ng;

		if(y>0 && x+L-1<w){

			ng=true;

			if(ng) rep(j,L) if(B[y-1][x+j]!=7) { ng=false; break; }

			if(ng) rep(j,L) if(B[y  ][x+j]!=(j==0||j==L-1?7:0)) { ng=false; break; }

			if(ng && y+1<h) rep(j,L) if(0<j && j<L-1 && B[y+1][x+j]!=0) { ng=false; break; }

			if(ng) return;



			ng=true;

			if(ng && y-2>=0) rep(j,L) if(0<j && j<L-1 && B[y-2][x+j]!=0) { ng=false; break; }

			if(ng) rep(j,L) if(B[y-1][x+j]!=(j==0||j==L-1?7:0)) { ng=false; break; }

			if(ng) rep(j,L) if(B[y  ][x+j]!=7) { ng=false; break; }

			if(ng) return;

		}

		if(y>0 && x-L+1>=0){

			ng=true;

			if(ng) rep(j,L) if(B[y-1][x-j]!=7) { ng=false; break; }

			if(ng) rep(j,L) if(B[y  ][x-j]!=(j==0||j==L-1?7:0)) { ng=false; break; }

			if(ng && y+1<h) rep(j,L) if(0<j && j<L-1 && B[y+1][x-j]!=0) { ng=false; break; }

			if(ng) return;



			ng=true;

			if(ng && y-2>=0) rep(j,L) if(0<j && j<L-1 && B[y-2][x-j]!=0) { ng=false; break; }

			if(ng) rep(j,L) if(B[y-1][x-j]!=(j==0||j==L-1?7:0)) { ng=false; break; }

			if(ng) rep(j,L) if(B[y  ][x-j]!=7) { ng=false; break; }

			if(ng) return;

		}

		if(y+L-1<h && x+1<w){

			ng=true;

			if(ng) rep(i,L) if(B[y+i][x  ]!=7) { ng=false; break; }

			if(ng) rep(i,L) if(B[y+i][x+1]!=(i==0||i==L-1?7:0)) { ng=false; break; }

			if(ng && x+2<w) rep(i,L) if(0<i && i<L-1 && B[y+i][x+2]!=0) { ng=false; break; }

			if(ng) return;



			ng=true;

			if(ng && x-1>=0) rep(i,L) if(0<i && i<L-1 && B[y+i][x-1]!=0) { ng=false; break; }

			if(ng) rep(i,L) if(B[y+i][x  ]!=(i==0||i==L-1?7:0)) { ng=false; break; }

			if(ng) rep(i,L) if(B[y+i][x+1]!=7) { ng=false; break; }

			if(ng) return;

		}

		if(y-L+1>=0 && x+1<w){

			ng=true;

			if(ng) rep(i,L) if(B[y-i][x  ]!=7) { ng=false; break; }

			if(ng) rep(i,L) if(B[y-i][x+1]!=(i==0||i==L-1?7:0)) { ng=false; break; }

			if(ng && x+2<w) rep(i,L) if(0<i && i<L-1 && B[y-i][x+2]!=0) { ng=false; break; }

			if(ng) return;



			ng=true;

			if(ng && x-1>=0) rep(i,L) if(0<i && i<L-1 && B[y-i][x-1]!=0) { ng=false; break; }

			if(ng) rep(i,L) if(B[y-i][x  ]!=(i==0||i==L-1?7:0)) { ng=false; break; }

			if(ng) rep(i,L) if(B[y-i][x+1]!=7) { ng=false; break; }

			if(ng) return;

		}

	}



	rep(k,4){

		int xx=x+dx[k],yy=y+dy[k];

		if(0<=xx && xx<w && 0<=yy && yy<h){

			if(B[yy][xx]==2){

				ans=now+1+bfs(x3,y3,3);

				return;

			}

			else if(B[yy][xx]==0){

				B[yy][xx]=7;

				dfs(xx,yy,now+1);

				B[yy][xx]=0;

			}

		}

	}

}



int main(){

	while(scanf(""%d%d"",&h,&w),h){

		rep(i,h) rep(j,w) scanf(""%d"",B[i]+j);



		rep(i,h) rep(j,w) {

			if(B[i][j]==2) x2=j, y2=i;

			if(B[i][j]==3) x3=j, y3=i;

		}

		B[y2][x2]=7; // 訪問済みのマーク



		ans=777;

		dfs(x2,y2,0);

		printf(""%d\n"",ans<777?ans:0);

	}



	return 0;

}",17.78,136.0,137.0,C++,cpp
u157859087,p00849,C++,s010454921,1110.0,1032.0,Accepted,"#include<cstdio>

#include<cstring>



#define rep(i,n) for(int i=0;i<(n);i++)



using namespace std;



const int dx[]={1,0,-1,0},dy[]={0,-1,0,1};



int h,w,B[9][9];



int x2,y2,x3,y3; // 2, 3 それぞれの出発点



int bfs(int x,int y,int tar){

	int d[9][9];

	memset(d,-1,sizeof d);

	d[y][x]=0;

	int Q[81],head=0,tail=0; Q[tail++]=y*w+x;

	while(head<tail){

		int i=Q[head]/w,j=Q[head]%w; head++;

		rep(k,4){

			int yy=i+dy[k],xx=j+dx[k];

			if(0<=yy && yy<h && 0<=xx && xx<w && d[yy][xx]==-1){

				if(B[yy][xx]==tar) return d[i][j]+1;

				if(B[yy][xx]== 0 ) Q[tail++]=yy*w+xx, d[yy][xx]=d[i][j]+1;

			}

		}

	}

	return 777;

}



int ans;

void dfs(int x,int y,int now){

	int hstar=bfs(x,y,2)+bfs(x3,y3,3);

	if(ans<now+1+hstar) return;



	// これまでのパスと接したら枝刈り

	int cnt=0;

	rep(k,4){

		int xx=x+dx[k],yy=y+dy[k];

		if(0<=xx && xx<w && 0<=yy && yy<h && B[yy][xx]==7) cnt++;

	}

	if(cnt>=2) return;



	// 777...777

	// 700...007

	// ?00...00?

	// というパターン ( or 回転して一致するもの ) があれば枝刈り

	for(int L=3;L<=8;L++){

		bool ng;

		if(y>0 && x+L-1<w){

			ng=true;

			if(ng) rep(j,L) if(B[y-1][x+j]!=7) { ng=false; break; }

			if(ng) rep(j,L) if(B[y  ][x+j]!=(j==0||j==L-1?7:0)) { ng=false; break; }

			if(ng && L>=5 && y+1<h) rep(j,L) if(0<j && j<L-1 && B[y+1][x+j]!=0) { ng=false; break; }

			if(ng) return;



			ng=true;

			if(ng && L>=5 && y-2>=0) rep(j,L) if(0<j && j<L-1 && B[y-2][x+j]!=0) { ng=false; break; }

			if(ng) rep(j,L) if(B[y-1][x+j]!=(j==0||j==L-1?7:0)) { ng=false; break; }

			if(ng) rep(j,L) if(B[y  ][x+j]!=7) { ng=false; break; }

			if(ng) return;

		}

		if(y>0 && x-L+1>=0){

			ng=true;

			if(ng) rep(j,L) if(B[y-1][x-j]!=7) { ng=false; break; }

			if(ng) rep(j,L) if(B[y  ][x-j]!=(j==0||j==L-1?7:0)) { ng=false; break; }

			if(ng && L>=5 && y+1<h) rep(j,L) if(0<j && j<L-1 && B[y+1][x-j]!=0) { ng=false; break; }

			if(ng) return;



			ng=true;

			if(ng && L>=5 && y-2>=0) rep(j,L) if(0<j && j<L-1 && B[y-2][x-j]!=0) { ng=false; break; }

			if(ng) rep(j,L) if(B[y-1][x-j]!=(j==0||j==L-1?7:0)) { ng=false; break; }

			if(ng) rep(j,L) if(B[y  ][x-j]!=7) { ng=false; break; }

			if(ng) return;

		}

		if(y+L-1<h && x+1<w){

			ng=true;

			if(ng) rep(i,L) if(B[y+i][x  ]!=7) { ng=false; break; }

			if(ng) rep(i,L) if(B[y+i][x+1]!=(i==0||i==L-1?7:0)) { ng=false; break; }

			if(ng && L>=5 && x+2<w) rep(i,L) if(0<i && i<L-1 && B[y+i][x+2]!=0) { ng=false; break; }

			if(ng) return;



			ng=true;

			if(ng && L>=5 && x-1>=0) rep(i,L) if(0<i && i<L-1 && B[y+i][x-1]!=0) { ng=false; break; }

			if(ng) rep(i,L) if(B[y+i][x  ]!=(i==0||i==L-1?7:0)) { ng=false; break; }

			if(ng) rep(i,L) if(B[y+i][x+1]!=7) { ng=false; break; }

			if(ng) return;

		}

		if(y-L+1>=0 && x+1<w){

			ng=true;

			if(ng) rep(i,L) if(B[y-i][x  ]!=7) { ng=false; break; }

			if(ng) rep(i,L) if(B[y-i][x+1]!=(i==0||i==L-1?7:0)) { ng=false; break; }

			if(ng && L>=5 && x+2<w) rep(i,L) if(0<i && i<L-1 && B[y-i][x+2]!=0) { ng=false; break; }

			if(ng) return;



			ng=true;

			if(ng && L>=5 && x-1>=0) rep(i,L) if(0<i && i<L-1 && B[y-i][x-1]!=0) { ng=false; break; }

			if(ng) rep(i,L) if(B[y-i][x  ]!=(i==0||i==L-1?7:0)) { ng=false; break; }

			if(ng) rep(i,L) if(B[y-i][x+1]!=7) { ng=false; break; }

			if(ng) return;

		}

	}



	rep(k,4){

		int xx=x+dx[k],yy=y+dy[k];

		if(0<=xx && xx<w && 0<=yy && yy<h){

			if(B[yy][xx]==2){

				ans=now+1+bfs(x3,y3,3);

				return;

			}

			else if(B[yy][xx]==0){

				B[yy][xx]=7;

				dfs(xx,yy,now+1);

				B[yy][xx]=0;

			}

		}

	}

}



int main(){

	while(scanf(""%d%d"",&h,&w),h){

		rep(i,h) rep(j,w) scanf(""%d"",B[i]+j);



		rep(i,h) rep(j,w) {

			if(B[i][j]==2) x2=j, y2=i;

			if(B[i][j]==3) x3=j, y3=i;

		}

		B[y2][x2]=7; // 訪問済みのマーク



		ans=777;

		dfs(x2,y2,0);

		printf(""%d\n"",ans<777?ans:0);

	}



	return 0;

}",17.78,136.0,137.0,C++,cpp
u157859087,p00849,C++,s010454921,1110.0,1032.0,Accepted,"#include<cstdio>

#include<cstring>



#define rep(i,n) for(int i=0;i<(n);i++)



using namespace std;



const int dx[]={1,0,-1,0},dy[]={0,-1,0,1};



int h,w,B[9][9];



int x2,y2,x3,y3; // 2, 3 それぞれの出発点



int bfs(int x,int y,int tar){

	int d[9][9];

	memset(d,-1,sizeof d);

	d[y][x]=0;

	int Q[81],head=0,tail=0; Q[tail++]=y*w+x;

	while(head<tail){

		int i=Q[head]/w,j=Q[head]%w; head++;

		rep(k,4){

			int yy=i+dy[k],xx=j+dx[k];

			if(0<=yy && yy<h && 0<=xx && xx<w && d[yy][xx]==-1){

				if(B[yy][xx]==tar) return d[i][j]+1;

				if(B[yy][xx]== 0 ) Q[tail++]=yy*w+xx, d[yy][xx]=d[i][j]+1;

			}

		}

	}

	return 777;

}



int ans;

void dfs(int x,int y,int now){

	int hstar=bfs(x,y,2)+bfs(x3,y3,3);

	if(ans<now+1+hstar) return;



	// これまでのパスと接したら枝刈り

	int cnt=0;

	rep(k,4){

		int xx=x+dx[k],yy=y+dy[k];

		if(0<=xx && xx<w && 0<=yy && yy<h && B[yy][xx]==7) cnt++;

	}

	if(cnt>=2) return;



	// 777...777

	// 700...007

	// ?00...00?

	// というパターン ( or 回転して一致するもの ) があれば枝刈り

	for(int L=3;L<=8;L++){

		bool ng;

		if(y>0 && x+L-1<w){

			ng=true;

			if(ng) rep(j,L) if(B[y-1][x+j]!=7) { ng=false; break; }

			if(ng) rep(j,L) if(B[y  ][x+j]!=(j==0||j==L-1?7:0)) { ng=false; break; }

			if(ng && L>=5 && y+1<h) rep(j,L) if(0<j && j<L-1 && B[y+1][x+j]!=0) { ng=false; break; }

			if(ng) return;



			ng=true;

			if(ng && L>=5 && y-2>=0) rep(j,L) if(0<j && j<L-1 && B[y-2][x+j]!=0) { ng=false; break; }

			if(ng) rep(j,L) if(B[y-1][x+j]!=(j==0||j==L-1?7:0)) { ng=false; break; }

			if(ng) rep(j,L) if(B[y  ][x+j]!=7) { ng=false; break; }

			if(ng) return;

		}

		if(y>0 && x-L+1>=0){

			ng=true;

			if(ng) rep(j,L) if(B[y-1][x-j]!=7) { ng=false; break; }

			if(ng) rep(j,L) if(B[y  ][x-j]!=(j==0||j==L-1?7:0)) { ng=false; break; }

			if(ng && L>=5 && y+1<h) rep(j,L) if(0<j && j<L-1 && B[y+1][x-j]!=0) { ng=false; break; }

			if(ng) return;



			ng=true;

			if(ng && L>=5 && y-2>=0) rep(j,L) if(0<j && j<L-1 && B[y-2][x-j]!=0) { ng=false; break; }

			if(ng) rep(j,L) if(B[y-1][x-j]!=(j==0||j==L-1?7:0)) { ng=false; break; }

			if(ng) rep(j,L) if(B[y  ][x-j]!=7) { ng=false; break; }

			if(ng) return;

		}

		if(y+L-1<h && x+1<w){

			ng=true;

			if(ng) rep(i,L) if(B[y+i][x  ]!=7) { ng=false; break; }

			if(ng) rep(i,L) if(B[y+i][x+1]!=(i==0||i==L-1?7:0)) { ng=false; break; }

			if(ng && L>=5 && x+2<w) rep(i,L) if(0<i && i<L-1 && B[y+i][x+2]!=0) { ng=false; break; }

			if(ng) return;



			ng=true;

			if(ng && L>=5 && x-1>=0) rep(i,L) if(0<i && i<L-1 && B[y+i][x-1]!=0) { ng=false; break; }

			if(ng) rep(i,L) if(B[y+i][x  ]!=(i==0||i==L-1?7:0)) { ng=false; break; }

			if(ng) rep(i,L) if(B[y+i][x+1]!=7) { ng=false; break; }

			if(ng) return;

		}

		if(y-L+1>=0 && x+1<w){

			ng=true;

			if(ng) rep(i,L) if(B[y-i][x  ]!=7) { ng=false; break; }

			if(ng) rep(i,L) if(B[y-i][x+1]!=(i==0||i==L-1?7:0)) { ng=false; break; }

			if(ng && L>=5 && x+2<w) rep(i,L) if(0<i && i<L-1 && B[y-i][x+2]!=0) { ng=false; break; }

			if(ng) return;



			ng=true;

			if(ng && L>=5 && x-1>=0) rep(i,L) if(0<i && i<L-1 && B[y-i][x-1]!=0) { ng=false; break; }

			if(ng) rep(i,L) if(B[y-i][x  ]!=(i==0||i==L-1?7:0)) { ng=false; break; }

			if(ng) rep(i,L) if(B[y-i][x+1]!=7) { ng=false; break; }

			if(ng) return;

		}

	}



	rep(k,4){

		int xx=x+dx[k],yy=y+dy[k];

		if(0<=xx && xx<w && 0<=yy && yy<h){

			if(B[yy][xx]==2){

				ans=now+1+bfs(x3,y3,3);

				return;

			}

			else if(B[yy][xx]==0){

				B[yy][xx]=7;

				dfs(xx,yy,now+1);

				B[yy][xx]=0;

			}

		}

	}

}



int main(){

	while(scanf(""%d%d"",&h,&w),h){

		rep(i,h) rep(j,w) scanf(""%d"",B[i]+j);



		rep(i,h) rep(j,w) {

			if(B[i][j]==2) x2=j, y2=i;

			if(B[i][j]==3) x3=j, y3=i;

		}

		B[y2][x2]=7; // 訪問済みのマーク



		ans=777;

		dfs(x2,y2,0);

		printf(""%d\n"",ans<777?ans:0);

	}



	return 0;

}",78.38,137.0,141.0,C++,cpp
u157859087,p00849,C++,s584360110,240.0,1032.0,Accepted,"#include<cstdio>

#include<cstring>



#define rep(i,n) for(int i=0;i<(n);i++)



using namespace std;



const int dx[]={1,0,-1,0},dy[]={0,-1,0,1};



int h,w,B[9][9];



int x2,y2,x3,y3; // 2, 3 それぞれの出発点



int bfs(int x,int y,int tar){

	int d[9][9];

	memset(d,-1,sizeof d);

	d[y][x]=0;

	int Q[81],head=0,tail=0; Q[tail++]=y*w+x;

	while(head<tail){

		int i=Q[head]/w,j=Q[head]%w; head++;

		rep(k,4){

			int yy=i+dy[k],xx=j+dx[k];

			if(0<=yy && yy<h && 0<=xx && xx<w && d[yy][xx]==-1){

				if(B[yy][xx]==tar) return d[i][j]+1;

				if(B[yy][xx]== 0 ) Q[tail++]=yy*w+xx, d[yy][xx]=d[i][j]+1;

			}

		}

	}

	return 777;

}



int ans;

void dfs(int x,int y,int now){

	int hstar=bfs(x,y,2)+bfs(x3,y3,3);

	if(ans<now+1+hstar) return;



	// これまでのパスと接したら枝刈り

	int cnt=0;

	rep(k,4){

		int xx=x+dx[k],yy=y+dy[k];

		if(0<=xx && xx<w && 0<=yy && yy<h && B[yy][xx]==7) cnt++;

	}

	if(cnt>=2) return;



	// 777...777

	// 700...007

	// ?00...00?

	// というパターン ( or 回転/反転して一致するもの ) があれば枝刈り

	for(int L=3;L<=8;L++){

		bool ng;

		if(y>0 && x+L-1<w){

			ng=true;

			if(ng) rep(j,L) if(B[y-1][x+j]!=7) { ng=false; break; }

			if(ng) rep(j,L) if(B[y  ][x+j]!=(j==0||j==L-1?7:0)) { ng=false; break; }

			if(ng && L>=5 && y+1<h) rep(j,L) if(0<j && j<L-1 && B[y+1][x+j]!=0) { ng=false; break; }

			if(ng) return;

		}

		if(y+1<h && x+L-1<w){

			ng=true;

			if(ng && L>=5 && y>0) rep(j,L) if(0<j && j<L-1 && B[y-1][x+j]!=0) { ng=false; break; }

			if(ng) rep(j,L) if(B[y  ][x+j]!=(j==0||j==L-1?7:0)) { ng=false; break; }

			if(ng) rep(j,L) if(B[y+1][x+j]!=7) { ng=false; break; }

			if(ng) return;

		}

		if(y>0 && x-L+1>=0){

			ng=true;

			if(ng) rep(j,L) if(B[y-1][x-j]!=7) { ng=false; break; }

			if(ng) rep(j,L) if(B[y  ][x-j]!=(j==0||j==L-1?7:0)) { ng=false; break; }

			if(ng && L>=5 && y+1<h) rep(j,L) if(0<j && j<L-1 && B[y+1][x-j]!=0) { ng=false; break; }

			if(ng) return;

		}

		if(y+1<h && x-L+1>=0){

			ng=true;

			if(ng && L>=5 && y>0) rep(j,L) if(0<j && j<L-1 && B[y-1][x-j]!=0) { ng=false; break; }

			if(ng) rep(j,L) if(B[y  ][x-j]!=(j==0||j==L-1?7:0)) { ng=false; break; }

			if(ng) rep(j,L) if(B[y+1][x-j]!=7) { ng=false; break; }

			if(ng) return;

		}

		if(y+L-1<h && x>0){

			ng=true;

			if(ng) rep(i,L) if(B[y+i][x-1]!=7) { ng=false; break; }

			if(ng) rep(i,L) if(B[y+i][x  ]!=(i==0||i==L-1?7:0)) { ng=false; break; }

			if(ng && L>=5 && x+1<w) rep(i,L) if(0<i && i<L-1 && B[y+i][x+1]!=0) { ng=false; break; }

			if(ng) return;

		}

		if(y+L-1<h && x+1<w){

			ng=true;

			if(ng && L>=5 && x>0) rep(i,L) if(0<i && i<L-1 && B[y+i][x-1]!=0) { ng=false; break; }

			if(ng) rep(i,L) if(B[y+i][x  ]!=(i==0||i==L-1?7:0)) { ng=false; break; }

			if(ng) rep(i,L) if(B[y+i][x+1]!=7) { ng=false; break; }

			if(ng) return;

		}

		if(y-L+1>=0 && x>0){

			ng=true;

			if(ng) rep(i,L) if(B[y-i][x-1]!=7) { ng=false; break; }

			if(ng) rep(i,L) if(B[y-i][x  ]!=(i==0||i==L-1?7:0)) { ng=false; break; }

			if(ng && L>=5 && x+1<w) rep(i,L) if(0<i && i<L-1 && B[y-i][x+1]!=0) { ng=false; break; }

			if(ng) return;

		}

		if(y-L+1>=0 && x+1<w){

			ng=true;

			if(ng && L>=5 && x>0) rep(i,L) if(0<i && i<L-1 && B[y-i][x-1]!=0) { ng=false; break; }

			if(ng) rep(i,L) if(B[y-i][x  ]!=(i==0||i==L-1?7:0)) { ng=false; break; }

			if(ng) rep(i,L) if(B[y-i][x+1]!=7) { ng=false; break; }

			if(ng) return;

		}

	}



	rep(k,4){

		int xx=x+dx[k],yy=y+dy[k];

		if(0<=xx && xx<w && 0<=yy && yy<h){

			if(B[yy][xx]==2){

				ans=now+1+bfs(x3,y3,3);

				return;

			}

			else if(B[yy][xx]==0){

				B[yy][xx]=7;

				dfs(xx,yy,now+1);

				B[yy][xx]=0;

			}

		}

	}

}



int main(){

	while(scanf(""%d%d"",&h,&w),h){

		rep(i,h) rep(j,w) scanf(""%d"",B[i]+j);



		rep(i,h) rep(j,w) {

			if(B[i][j]==2) x2=j, y2=i;

			if(B[i][j]==3) x3=j, y3=i;

		}

		B[y2][x2]=7; // 訪問済みのマーク



		ans=777;

		dfs(x2,y2,0);

		printf(""%d\n"",ans<777?ans:0);

	}



	return 0;

}",78.38,137.0,141.0,C++,cpp
u157859087,p00849,C++,s584360110,240.0,1032.0,Accepted,"#include<cstdio>

#include<cstring>



#define rep(i,n) for(int i=0;i<(n);i++)



using namespace std;



const int dx[]={1,0,-1,0},dy[]={0,-1,0,1};



int h,w,B[9][9];



int x2,y2,x3,y3; // 2, 3 それぞれの出発点



int bfs(int x,int y,int tar){

	int d[9][9];

	memset(d,-1,sizeof d);

	d[y][x]=0;

	int Q[81],head=0,tail=0; Q[tail++]=y*w+x;

	while(head<tail){

		int i=Q[head]/w,j=Q[head]%w; head++;

		rep(k,4){

			int yy=i+dy[k],xx=j+dx[k];

			if(0<=yy && yy<h && 0<=xx && xx<w && d[yy][xx]==-1){

				if(B[yy][xx]==tar) return d[i][j]+1;

				if(B[yy][xx]== 0 ) Q[tail++]=yy*w+xx, d[yy][xx]=d[i][j]+1;

			}

		}

	}

	return 777;

}



int ans;

void dfs(int x,int y,int now){

	int hstar=bfs(x,y,2)+bfs(x3,y3,3);

	if(ans<now+1+hstar) return;



	// これまでのパスと接したら枝刈り

	int cnt=0;

	rep(k,4){

		int xx=x+dx[k],yy=y+dy[k];

		if(0<=xx && xx<w && 0<=yy && yy<h && B[yy][xx]==7) cnt++;

	}

	if(cnt>=2) return;



	// 777...777

	// 700...007

	// ?00...00?

	// というパターン ( or 回転/反転して一致するもの ) があれば枝刈り

	for(int L=3;L<=8;L++){

		bool ng;

		if(y>0 && x+L-1<w){

			ng=true;

			if(ng) rep(j,L) if(B[y-1][x+j]!=7) { ng=false; break; }

			if(ng) rep(j,L) if(B[y  ][x+j]!=(j==0||j==L-1?7:0)) { ng=false; break; }

			if(ng && L>=5 && y+1<h) rep(j,L) if(0<j && j<L-1 && B[y+1][x+j]!=0) { ng=false; break; }

			if(ng) return;

		}

		if(y+1<h && x+L-1<w){

			ng=true;

			if(ng && L>=5 && y>0) rep(j,L) if(0<j && j<L-1 && B[y-1][x+j]!=0) { ng=false; break; }

			if(ng) rep(j,L) if(B[y  ][x+j]!=(j==0||j==L-1?7:0)) { ng=false; break; }

			if(ng) rep(j,L) if(B[y+1][x+j]!=7) { ng=false; break; }

			if(ng) return;

		}

		if(y>0 && x-L+1>=0){

			ng=true;

			if(ng) rep(j,L) if(B[y-1][x-j]!=7) { ng=false; break; }

			if(ng) rep(j,L) if(B[y  ][x-j]!=(j==0||j==L-1?7:0)) { ng=false; break; }

			if(ng && L>=5 && y+1<h) rep(j,L) if(0<j && j<L-1 && B[y+1][x-j]!=0) { ng=false; break; }

			if(ng) return;

		}

		if(y+1<h && x-L+1>=0){

			ng=true;

			if(ng && L>=5 && y>0) rep(j,L) if(0<j && j<L-1 && B[y-1][x-j]!=0) { ng=false; break; }

			if(ng) rep(j,L) if(B[y  ][x-j]!=(j==0||j==L-1?7:0)) { ng=false; break; }

			if(ng) rep(j,L) if(B[y+1][x-j]!=7) { ng=false; break; }

			if(ng) return;

		}

		if(y+L-1<h && x>0){

			ng=true;

			if(ng) rep(i,L) if(B[y+i][x-1]!=7) { ng=false; break; }

			if(ng) rep(i,L) if(B[y+i][x  ]!=(i==0||i==L-1?7:0)) { ng=false; break; }

			if(ng && L>=5 && x+1<w) rep(i,L) if(0<i && i<L-1 && B[y+i][x+1]!=0) { ng=false; break; }

			if(ng) return;

		}

		if(y+L-1<h && x+1<w){

			ng=true;

			if(ng && L>=5 && x>0) rep(i,L) if(0<i && i<L-1 && B[y+i][x-1]!=0) { ng=false; break; }

			if(ng) rep(i,L) if(B[y+i][x  ]!=(i==0||i==L-1?7:0)) { ng=false; break; }

			if(ng) rep(i,L) if(B[y+i][x+1]!=7) { ng=false; break; }

			if(ng) return;

		}

		if(y-L+1>=0 && x>0){

			ng=true;

			if(ng) rep(i,L) if(B[y-i][x-1]!=7) { ng=false; break; }

			if(ng) rep(i,L) if(B[y-i][x  ]!=(i==0||i==L-1?7:0)) { ng=false; break; }

			if(ng && L>=5 && x+1<w) rep(i,L) if(0<i && i<L-1 && B[y-i][x+1]!=0) { ng=false; break; }

			if(ng) return;

		}

		if(y-L+1>=0 && x+1<w){

			ng=true;

			if(ng && L>=5 && x>0) rep(i,L) if(0<i && i<L-1 && B[y-i][x-1]!=0) { ng=false; break; }

			if(ng) rep(i,L) if(B[y-i][x  ]!=(i==0||i==L-1?7:0)) { ng=false; break; }

			if(ng) rep(i,L) if(B[y-i][x+1]!=7) { ng=false; break; }

			if(ng) return;

		}

	}



	rep(k,4){

		int xx=x+dx[k],yy=y+dy[k];

		if(0<=xx && xx<w && 0<=yy && yy<h){

			if(B[yy][xx]==2){

				ans=now+1+bfs(x3,y3,3);

				return;

			}

			else if(B[yy][xx]==0){

				B[yy][xx]=7;

				dfs(xx,yy,now+1);

				B[yy][xx]=0;

			}

		}

	}

}



int main(){

	while(scanf(""%d%d"",&h,&w),h){

		rep(i,h) rep(j,w) scanf(""%d"",B[i]+j);



		rep(i,h) rep(j,w) {

			if(B[i][j]==2) x2=j, y2=i;

			if(B[i][j]==3) x3=j, y3=i;

		}

		B[y2][x2]=7; // 訪問済みのマーク



		ans=777;

		dfs(x2,y2,0);

		printf(""%d\n"",ans<777?ans:0);

	}



	return 0;

}",16.67,141.0,141.0,C++,cpp
u157859087,p00849,C++,s838450708,200.0,1032.0,Accepted,"#include<cstdio>

#include<cstring>



#define rep(i,n) for(int i=0;i<(n);i++)



using namespace std;



const int dx[]={1,0,-1,0},dy[]={0,-1,0,1};



int h,w,B[9][9];



int x2,y2,x3,y3; // 2, 3 それぞれの出発点



int bfs(int x,int y,int tar){

	int d[9][9];

	memset(d,-1,sizeof d);

	d[y][x]=0;

	int Q[81],head=0,tail=0; Q[tail++]=y*w+x;

	while(head<tail){

		int i=Q[head]/w,j=Q[head]%w; head++;

		rep(k,4){

			int yy=i+dy[k],xx=j+dx[k];

			if(0<=yy && yy<h && 0<=xx && xx<w && d[yy][xx]==-1){

				if(B[yy][xx]==tar) return d[i][j]+1;

				if(B[yy][xx]== 0 ) Q[tail++]=yy*w+xx, d[yy][xx]=d[i][j]+1;

			}

		}

	}

	return 777;

}



int ans;

void dfs(int x,int y,int now){

	int hstar=bfs(x,y,2)+bfs(x3,y3,3);

	if(ans<now+1+hstar) return;



	// これまでのパスと接したら枝刈り

	int cnt=0;

	rep(k,4){

		int xx=x+dx[k],yy=y+dy[k];

		if(0<=xx && xx<w && 0<=yy && yy<h && B[yy][xx]==7) cnt++;

	}

	if(cnt>=2) return;



	// 777...777

	// 700...007

	// ?00...00?

	// というパターン ( or 回転/反転して一致するもの ) があれば枝刈り

	for(int L=3;L<=8;L++){

		bool ng;

		if(y>0 && x+L-1<w){

			ng=true;

			if(ng) rep(j,L) if(B[y-1][x+j]!=7) { ng=false; break; }

			if(ng) rep(j,L) if(B[y  ][x+j]!=(j==0||j==L-1?7:0)) { ng=false; break; }

			if(ng && L>=5 && y+1<h) rep(j,L) if(0<j && j<L-1 && B[y+1][x+j]!=0) { ng=false; break; }

			if(ng) return;

		}

		if(y+1<h && x+L-1<w){

			ng=true;

			if(ng && L>=5 && y>0) rep(j,L) if(0<j && j<L-1 && B[y-1][x+j]!=0) { ng=false; break; }

			if(ng) rep(j,L) if(B[y  ][x+j]!=(j==0||j==L-1?7:0)) { ng=false; break; }

			if(ng) rep(j,L) if(B[y+1][x+j]!=7) { ng=false; break; }

			if(ng) return;

		}

		if(y>0 && x-L+1>=0){

			ng=true;

			if(ng) rep(j,L) if(B[y-1][x-j]!=7) { ng=false; break; }

			if(ng) rep(j,L) if(B[y  ][x-j]!=(j==0||j==L-1?7:0)) { ng=false; break; }

			if(ng && L>=5 && y+1<h) rep(j,L) if(0<j && j<L-1 && B[y+1][x-j]!=0) { ng=false; break; }

			if(ng) return;

		}

		if(y+1<h && x-L+1>=0){

			ng=true;

			if(ng && L>=5 && y>0) rep(j,L) if(0<j && j<L-1 && B[y-1][x-j]!=0) { ng=false; break; }

			if(ng) rep(j,L) if(B[y  ][x-j]!=(j==0||j==L-1?7:0)) { ng=false; break; }

			if(ng) rep(j,L) if(B[y+1][x-j]!=7) { ng=false; break; }

			if(ng) return;

		}

		if(y+L-1<h && x>0){

			ng=true;

			if(ng) rep(i,L) if(B[y+i][x-1]!=7) { ng=false; break; }

			if(ng) rep(i,L) if(B[y+i][x  ]!=(i==0||i==L-1?7:0)) { ng=false; break; }

			if(ng && L>=5 && x+1<w) rep(i,L) if(0<i && i<L-1 && B[y+i][x+1]!=0) { ng=false; break; }

			if(ng) return;

		}

		if(y+L-1<h && x+1<w){

			ng=true;

			if(ng && L>=5 && x>0) rep(i,L) if(0<i && i<L-1 && B[y+i][x-1]!=0) { ng=false; break; }

			if(ng) rep(i,L) if(B[y+i][x  ]!=(i==0||i==L-1?7:0)) { ng=false; break; }

			if(ng) rep(i,L) if(B[y+i][x+1]!=7) { ng=false; break; }

			if(ng) return;

		}

		if(y-L+1>=0 && x>0){

			ng=true;

			if(ng) rep(i,L) if(B[y-i][x-1]!=7) { ng=false; break; }

			if(ng) rep(i,L) if(B[y-i][x  ]!=(i==0||i==L-1?7:0)) { ng=false; break; }

			if(ng && L>=5 && x+1<w) rep(i,L) if(0<i && i<L-1 && B[y-i][x+1]!=0) { ng=false; break; }

			if(ng) return;

		}

		if(y-L+1>=0 && x+1<w){

			ng=true;

			if(ng && L>=5 && x>0) rep(i,L) if(0<i && i<L-1 && B[y-i][x-1]!=0) { ng=false; break; }

			if(ng) rep(i,L) if(B[y-i][x  ]!=(i==0||i==L-1?7:0)) { ng=false; break; }

			if(ng) rep(i,L) if(B[y-i][x+1]!=7) { ng=false; break; }

			if(ng) return;

		}

	}



	for(int k=3;k>=0;k--){

		int xx=x+dx[k],yy=y+dy[k];

		if(0<=xx && xx<w && 0<=yy && yy<h){

			if(B[yy][xx]==2){

				ans=now+1+bfs(x3,y3,3);

				return;

			}

			else if(B[yy][xx]==0){

				B[yy][xx]=7;

				dfs(xx,yy,now+1);

				B[yy][xx]=0;

			}

		}

	}

}



int main(){

	while(scanf(""%d%d"",&h,&w),h){

		rep(i,h) rep(j,w) scanf(""%d"",B[i]+j);



		rep(i,h) rep(j,w) {

			if(B[i][j]==2) x2=j, y2=i;

			if(B[i][j]==3) x3=j, y3=i;

		}

		B[y2][x2]=7; // 訪問済みのマーク



		ans=777;

		dfs(x2,y2,0);

		printf(""%d\n"",ans<777?ans:0);

	}



	return 0;

}",16.67,141.0,141.0,C++,cpp
u005006157,p03352,C++,s599184632,2205.0,3384.0,Time Limit Exceeded,"#include <bits/stdc++.h>

#define rep(i,n) for (int i = 0; i < (n); ++i)

using namespace std;

using ll = long long;

using P = pair<int,int>;

#define chmax(x,y) x = max(x,y);

#define chmin(x,y) x = min(x,y);

const int di[] = {-1, 0, 1, 0};

const int dj[] = {0, -1, 0, 1};

const int INF = 1001001001;







int main() {

    int x;

    cin >> x;

    int ans = 0;

    for (int i = 1; i <= 33; i++) {

        for (int j = i; j <= x; j *= i) {

            ans = max(ans, j);

        }

    }

    cout << ans << endl;

    return 0;

}",99.64,25.0,26.0,C++ (GCC 9.2.1),cpp
u005006157,p03352,C++,s655253243,8.0,3548.0,Accepted,"#include <bits/stdc++.h>

#define rep(i,n) for (int i = 0; i < (n); ++i)

using namespace std;

using ll = long long;

using P = pair<int,int>;

#define chmax(x,y) x = max(x,y);

#define chmin(x,y) x = min(x,y);

const int di[] = {-1, 0, 1, 0};

const int dj[] = {0, -1, 0, 1};

const int INF = 1001001001;







int main() {

    int x;

    cin >> x;

    int ans = 0;

    for (int i = 1; i <= 33; i++) {

        for (int j = i*i; j <= x; j *= i) {

            ans = max(ans, j);

            if (j == 1) break;

        }

    }

    cout << ans << endl;

    return 0;

}",99.64,25.0,26.0,C++ (GCC 9.2.1),cpp
u006472158,p03352,C++,s997333948,2103.0,256.0,Time Limit Exceeded,"#include <bits/stdc++.h>

using namespace std;

int main() {

  int x,ans=1; cin>>x;

  for(int b=1; b<=x; b++){

    int tmp=b*b;

    while(tmp<=x){

      ans=max(ans,tmp);

      tmp*=b;

    }

  }

  cout<<ans;

}",99.95,13.0,13.0,C++14 (GCC 5.4.1),cpp
u006472158,p03352,C++,s025566116,1.0,256.0,Accepted,"#include <bits/stdc++.h>

using namespace std;

int main() {

  int x,ans=1; cin>>x;

  for(int b=2; b<=x; b++){

    int tmp=b*b;

    while(tmp<=x){

      ans=max(ans,tmp);

      tmp*=b;

    }

  }

  cout<<ans;

}",99.95,13.0,13.0,C++14 (GCC 5.4.1),cpp
u017881341,p03352,C++,s224817569,2103.0,256.0,Time Limit Exceeded,"#include<iostream>

using namespace std;



int main()

{

  int x;

  cin >> x;



  int i;

  while(1){

    if(i*i > x) break;

  }



  cout << (i-1)*(i-1) << endl;



  return 0;



}
",99.95,18.0,26.0,C++14 (GCC 5.4.1),cpp
u017881341,p03352,C++,s941353487,1.0,256.0,Accepted,"#include<iostream>

using namespace std;



int main()

{

  int x;

  cin >> x;



  int ans = 1;



  for(int i = 2; i*i <= x; i++){

    int cnt = i*i;



    while(cnt <= x) cnt *= i;



    cnt /= i;

    if(cnt > ans) ans = cnt;



  }



  cout << ans << endl;



  return 0;



}


",99.95,18.0,26.0,C++14 (GCC 5.4.1),cpp
u018679195,p03352,C++,s898825236,2.0,256.0,Accepted,"#include<cstdio>

#include<cmath>

#include<algorithm>

using namespace std;

int f[300],l=1;

int main()

{

	f[0]=1;

	for (int p=2;p<10;p++)

		for(int b=2;b<32;b++)

		{

			int m=p,k=b,t=1;

			while (m)

			{

				if (m&1) t*=k;

				m>>=1;

				k*=k;

			}

			f[l++]=t;

		}

	int x,minn=0;

	scanf(""%d"",&x);

	for (int i=0;i<l;i++)

		if (x>=f[i] && minn<f[i])

			minn=f[i];

	printf(""%d"",minn);

}",50.0,27.0,25.0,C++14 (GCC 5.4.1),cpp
u018679195,p03352,C++,s541645467,1.0,256.0,Accepted,"#include<iostream>

#include<cstring>

#include<cmath>

using namespace std;

bool x[1001];

int n,i,j;

int main(){

	cin>>n;

	memset(x,0,sizeof(x));

	x[1]=1;

	for(i=1;i<=31;i++){

		for(j=2;j<=10;j++){

			if(pow(i,j)<=1000){

				x[(int)(pow((double)i,(double)j))]=1;

			}

			else break;

		}

	}

	for(i=n;i>0;i--){

		if(x[i]==1){

			cout<<i;

			return 0;

		}

	}

}",50.0,27.0,25.0,C++14 (GCC 5.4.1),cpp
u018679195,p03352,C++,s743140059,57.0,4128.0,Accepted,"#include<bits/stdc++.h>

using namespace std;

#define int long long

signed main(){

	int n;

	cin>>n;

	int count=0;

	int k=sqrt(n);

	int maxi=1;

	for(int i=1; i<n; i++){

		for(int j=2; j<n; j++){

			if(pow(i,j)<=n){

			count=pow(i,j);

			maxi=max(count,maxi);

		//	cout<<i<<"" ""<<j<<"" ""<<maxi<<endl;

		}

	}}

	cout<<maxi;

}",85.96,19.0,15.0,C++ (GCC 9.2.1),cpp
u018679195,p03352,C++,s147468699,8.0,3604.0,Accepted,"#include <bits/stdc++.h>

using namespace std;



int main() {

	int n; cin >> n;

	int mx = 1;

	for (int i = 2; i * i <= n; ++i) {

		int s = i;

		while (s * i <= n)

			s *= i;

		mx = max(s, mx);

	}

	cout << mx;

	return 0;

}",85.96,19.0,15.0,C++ (GCC 9.2.1),cpp
u028572059,p03352,C++,s682141149,2103.0,256.0,Time Limit Exceeded,"#include <bits/stdc++.h>

using namespace std;

#define ALL(a) (a).begin(),(a).end()

#define rALL(a) (a).rbegin(),(a).rend()

typedef pair<int, int> P;

typedef pair<int64_t, int64_t> Pll;

  

int main() {

    int X;

    cin >> X;

    int j = 2;



    while (true) {

        if (X == 1) {

            cout << 1 << endl;

        }

        for (int i = 2; i * i <= X; i++) {

            while (pow(i, j) <= X) {

                if (pow(i, j) == X) {

                    cout << X << endl;

                    return 0;

                }

                j++;

            }

            j = 2;

        }

        X--;

    }

}",99.9,29.0,30.0,C++14 (GCC 5.4.1),cpp
u028572059,p03352,C++,s218350213,2.0,256.0,Accepted,"#include <bits/stdc++.h>

using namespace std;

#define ALL(a) (a).begin(),(a).end()

#define rALL(a) (a).rbegin(),(a).rend()

typedef pair<int, int> P;

typedef pair<int64_t, int64_t> Pll;

  

int main() {

    int X;

    cin >> X;

    int j = 2;



    while (true) {

        if (X == 1) {

            cout << 1 << endl;

            return 0;

        }

        for (int i = 2; i * i <= X; i++) {

            while (pow(i, j) <= X) {

                if (pow(i, j) == X) {

                    cout << X << endl;

                    return 0;

                }

                j++;

            }

            j = 2;

        }

        X--;

    }

}",99.9,29.0,30.0,C++14 (GCC 5.4.1),cpp
u031178961,p03352,C++,s811799986,3.0,512.0,Accepted,"#include<algorithm>

#include<iostream>

#include<vector>

#include<string>

#include<map>

#include<stack>

#include<queue>

#include<cmath>



typedef long long i64;



using namespace std;



int main(){

    int N;

    cin>>N;

    int ans = 0;

    int num = 1e9;



    if(N == 1){

        cout<<""1\n"";

        return 0;

    }





    for(int i=2;i<=N;i++){

        for(int j = 2; pow(i,j)<=N; j++){

            int X = N - pow(i,j);

            if(num > X){

                num = X;

                ans = pow(i,j); 

            }

        }

    }



    cout<<ans<<endl;





}",33.33,39.0,22.0,C++14 (GCC 5.4.1),cpp
u031178961,p03352,C++,s778653657,2.0,256.0,Accepted,"#include<bits/stdc++.h>

using namespace std;



int main(){

  long X;

  cin >> X;

  long ans = 0;

  while(!ans){

    long x = X--;

    for(int i = 2; i <= x; i++){

      long tmp = x;

      int cnt = 0;

      while(tmp % i == 0) {

        tmp /= i;

        cnt++;

      }

      if(tmp == 1 && cnt > 1) ans = x;

    }

    if(x == 1) ans = 1;

  }

  cout << ans << endl;

}
",33.33,39.0,22.0,C++14 (GCC 5.4.1),cpp
u037563046,p03352,C++,s146504466,55.0,256.0,Accepted,"/*01 02 03 12 13 23　と６回見ていくパターン 

for(int i=0;i<n-1;i++){

  for(int j=i+1;j<n;j++){

    }

  }

*///vector<vector<int>> data(3, vector<int>(4));//int型の2次元配列(3×4要素の)の宣言

//int64_t a;

//10のi乗pow(10, i);

/*string s; stringでの文字列を数字型に変える方法

  cin >> s;

  rep(i,s.size()-2) {

  int a= (s.at(i)-'0')*100 + (s.at(i+1)-'0')*10+ s.at(i+2) -'0';

    */

#include <bits/stdc++.h>

using namespace std;

#define rep(i, n) for (int i = 0; i < (int)(n); i++)

//  cout <<  s.at(1)-'0'-49  <<endl;

int main() {

  int x;

  cin >> x;

  int ma=0;

  int m=0;

  

  for(int i=1;i<1000;i++){

    for(int j=2;j<1000;j++){

      if(x >= pow(i, j) ) m = pow(i, j);

      ma = max(ma,m);

    }

  }

  cout << ma <<endl;

}",85.45,31.0,566.0,C++14 (GCC 5.4.1),cpp
u037563046,p03352,C++,s199133962,8.0,3624.0,Accepted,"/*

abc168 double dots

int main() {

  int n,m;

  cin >> n >> m;

  Graph G(n);

  rep(i,m){

    int a,b;

    cin >> a >> b;

    --a;--b;

    G[a].push_back(b);

    G[b].push_back(a);

  }

  

  //BFSのためのデータ構造

  vector<int>dist(n,-1);

  queue<int>q;

  vector<int>prev(n,-1);

  

  //初期条件（頂点０を初期ノードとする

  dist[0] = 0;

  q.push(0);

  

  //BFS開始

  while(!q.empty()){

    int v = q.front();

    q.pop();

    

    //vから辿れる頂点を全て調べる

    for(int nv : G[v]){

      if(dist[nv] != -1)continue;

      

      dist[nv] = dist[v] + 1;

      prev[nv] = v;

      q.push(nv);

    }

  }

  cout << ""Yes""<<endl;

  rep(i,n){

    if(i==0)continue;

    cout << prev[i] + 1 << endl;

  }

}

*/

/*

// ABC141 D - Powerful Discount Tickets

// 優先度キュー プライオリティーキュー

int main() {

  ll n,m;

  cin >> n >> m;

  // プライオリティーキューに突っ込む

  priority_queue<ll> q;

  rep(i,n){

    ll k;

    cin >> k;

    q.push(k);

  }

  

  // 値段の高いものから割引券を適応して戻す

  rep(i,m){

     ll now = q.top();

     q.pop();

     now /= 2;

     q.push(now);

   }



  // 結果的に合計いくらになったか計算する

   ll ans = 0;

   while (!q.empty()) {

     ans += q.top();

     q.pop();

   }

   cout << ans << endl;

}

*/

/*

ABC026 高橋君の給料 DFS

int dfs(int n,vector<vector<int>> G){

  int mi = 1000000000;

  int ma = 0;

  int w,v;

  for(int i=0;i<G[n].size();i++){

    v = G[n][i];

    if(G[v].size() == 0)w = 1;

    else w = dfs(v,G);

    

    mi = min(mi,w);

    ma = max(ma,w);

  }

  return mi + ma + 1;

}

int main() {

  int n;

  cin >> n;

  Graph G(n+1);

  for(int i=2;i<=n;i++){

    int a;

    cin >> a;

    G[a].push_back(i);

  }

  int ans = dfs(1,G);

  cout << ans << endl;

}

*/

//素因数分解

//ABC169-D - Div Game

/*

int main() {

  ll n;

  cin >> n;

  vector<pair<ll,ll> > res;

  for(ll i = 2;i*i <= n;i++){

    if(n % i !=0) continue;

    ll ex = 0;// 指数

    

    //割れる限り割り続ける

    while(n % i ==0){

      ex++;

      n /=i;

    }

    

    //その結果をpush

    res.push_back({i,ex});

  }

  

  //最後に残った数について

  if(n !=1) res.push_back({n,1});

  

//    cout << n << "":"";

//    for (auto p : res) {

//        for (int i = 0; i < p.second; ++i) cout << "" "" << p.first;

//    }

//   cout << endl;

  

  ll times = 0;

    for (auto p : res) {

      int count = 1;

      int cnt = 0;

       while(p.second > cnt){

//         cout << p.second << endl;

         p.second -=count;

         count++;

         cnt ++;

       }

      times += cnt;

    }

  cout << times << endl;

}

*/

  //ABC146 //二分探索

/*int main() {

  ll a,b,x;

  cin >> a >> b >> x;

  ll left = 0;

  ll right = 1000000001;

  while(right - left > 1){

    ll mid = (left + right ) /2;

    if(a * mid + b * ketasuu(mid) > x) right = mid;

    else left = mid;

//    cout << left << "" "" << right  << endl;

  }

  cout << left << endl;

}

*/



//ABC_128_B// pair型の中にpair型

/*int main() {

  int n;

  cin >> n;

  vector<pair<pair<string,int>,int>> a(n);

  for(int i=0;i<n;i++){

    string s;

    cin >> s;

    int num;

    cin >> num;

    num = num * -1;



    a.at(i).first.first  = s;

    a.at(i).first.second = num;

    a.at(i).second 		 = i;

  }

  sort(a.begin(), a.end());

  for(int i=0;i<n;i++){

    cout <<   a.at(i).second +1 << endl;

  }

}

*/

//ABC_058_Cのように

// s.at(j) == a のとき

//cout << s.at(j)-'0' - 49 << endl;

//とすると、「0」を出力してくれる。　→もっといいほかの方法はないの？



//全bit探索を入れよう!!

/*ABC_167_C skill up などを参考に…

//https://qiita.com/hareku/items/3d08511eab56a481c7db

int main() {

    int n = 3;



    // {0, 1, ..., n-1} の部分集合の全探索

    for (int bit = 0; bit < (1<<n); ++bit) {

        vector<int> S;

        for (int i = 0; i < n; ++i) {

            if (bit & (1<<i)) { // 列挙に i が含まれるか

                S.push_back(i);

            }

        }



        cout << bit << "": {"";

        for (int i = 0; i < (int)S.size(); ++i) {

            cout << S[i] << "" "";

        }

        cout << ""}"" << endl;

    }

}

*/

//next_permutation（順列列挙）

/*https://note.com/memenekokaburi/n/nf0201d6002cd

//https://scrapbox.io/ganariya/AtCoderGrandContest022_A%E5%95%8F%E9%A1%8C300%E7%82%B9%E3%80%8CDiverse_Word%E3%80%8D_(copy)

//https://atcoder.jp/contests/agc022/tasks/agc022_a

ABC_150_Cなど。

int main() {

  int n;

  cin >> n ;

   vector<int>array = {};

   for(int i=0;i<n;i++){

    array.push_back(i);

   }

  do{

        for(int i=0; i<n; i++){

            cout << array.at(i);

            if(i!=n-1)cout<<"" "";

        }

        cout<<endl;

    }while(next_permutation(array.begin(),array.end()));

    return 0;

}

*/



//ABC126_Cのように関数でdouble型で返ってきてほしい場合はdouble kan_halfのようにかく

/*

//ABC_041_C// pair型

int main() {

  int n;

  cin >> n;

  vector<pair<int,int>>a(n);

  for(int i=0;i<n;i++){

    int num;

    cin >> num;

    a.at(i).first  = num;

    a.at(i).second = i;

  }

  sort(a.begin(), a.end());

  reverse(a.begin(),a.end());

  for(int i=0;i<n;i++){

    cout << a.at(i).second + 1<< endl;

  }

}

*/

/*ABC_068_C //boolの配列を使って

bool s[200050] = {};

bool t[200050] = {};

int main() {

	ll n, m; cin >> n >> m;

	for (int i = 0; i < m; i++){

		ll a, b; cin >> a >> b;

		if (a == 1) {

			t[b] = true;

		}

		if (b == n) {

			s[a] = true;

		}

	}

	for (int i = 0; i < 200050; i++){

		if (s[i] && t[i]) {

			cout << ""POSSIBLE"" << endl;

			return 0;

		}

	}

	cout << ""IMPOSSIBLE"" << endl;

	return 0;

}

*/



//int32	4	signed, signed int, int	-2,147,483,648 ～ 2,147,483,647 = 2*10^9

//再帰関数 ABC_029_C

/*

void f(int rest , string s){

  if(rest == 0){

    cout << s << endl;

  }

  else{

    for(char moji = 'a' ;moji <='c' ; moji++){

      f(rest-1,s+moji);

    } 

  }

}

 

int main() {

  int n;

  cin >> n;

  f(n, """");

}

*/

//連想配列 ARC_081_Cの解答 //ABC073でも復習できます。

//std::mapの内部ではキーが昇順になるように要素がソートされているので、

//イテレータを.begin()から順にみることで、キーを昇順に見ることが出来ます

/*

int main() {

  ll n;

  cin >> n;

  vector<ll>a(n);

  rep(i,n) cin>>a.at(i);

  map<ll,ll>mp;

  rep(i,n){

    mp[a.at(i)]++;

  }

  ll one  = 0;

  ll two = 0;

  for(auto p:mp){

//    cout << p.first << "" "" << p.second << endl;

    if(p.second >= 2){

      if(one <= p.first){

        two = one;

        one = p.first;

      }

    }

    if(p.second >= 4){

      if(one <= p.first){

        two = p.first;

        one = p.first;

      }

    }

  }

//  cout << one << endl;

//  cout << two << endl;

//  cout << endl;

  cout << one * two << endl;

}

*/



//関数

/*

ll gcd(ll a, ll b){

   if (a%b == 0){

       return(b);

   }

   else{

       return(gcd(b, a%b));

   }

}



ll lcm(ll a, ll b){

//   return a * b / gcd(a, b);

     return a / gcd(a, b)* b;

}



int kan_hyaku(int n){

  int kurai = 0;

  for(int i=0;i<3;i++){

    kurai = n%10;

    n /=10;

  }

  return kurai;

}

int kan_ju(int n){

  int kurai = 0;

  for(int i=0;i<2;i++){

    kurai = n%10;

    n /=10;

  }

  return kurai;

}

int kan_ichi(int n){

  int kurai = 0;

  for(int i=0;i<1;i++){

    kurai = n%10;

    n /=10;

  }

  return kurai;

}



ll keta(ll n){

  ll wa = 1;

  while(n>0){

    wa *=10;

    n--;

  }

  return wa;

}



double kan_half(int n){

  double wa = 1;

  while(n>0){

//    cout << ""TEST""<<endl;

    wa *= 0.5;

//    cout << wa << endl;

    n--;

  }

  return wa;

}



ll facctorialMethod(ll k){

    ll sum = 1;

    for (ll i = 1; i <= k; ++i)

    {

        sum = sum%1000000007 * i%1000000007;

    }

    return sum;

}



int zorocheck(string s){

  int count = 0;

  rep(i,s.size()){

    if(s.at(i) == s.at(0)) count++;

  }

  if(count ==s.size()){

    return 1;

  }

  else{

    return 0;

  }

}



int sannobekijou(int n){

  int wa = 1;

  while(n>0){

    n--;

    wa *=3;

  }

  return wa;

}

ll ketasuu(ll k){

  ll wa = 0;

  while(k > 0){

    k /=10;

    wa++;

  }

  return wa;

}

ll beki(ll f,ll num){

  ll wa = 1;

  while(num > 0){

    wa *= f;

    num--;

//    cout << wa << endl;

  }

  return wa;

}

ll fibona(ll num){

  vector<ll>c(3);

  c.at(0) = 1;

  c.at(1) = 2;

  c.at(2) = 3;

  if(num == 1){

    return c.at(0);

  }

  else if(num == 2){

    return c.at(1);

  }

  else if(num == 3){

    return c.at(2);

  }

  else{

    for(ll i = 3; i < num;i++){

//      cout << "" tes "" << endl;

      ll tmp;

      tmp = c.at(1) + c.at(2);

      tmp %= 1000000007;

      c.at(0) = c.at(1);

      c.at(1) = c.at(2);

      c.at(2) = tmp;

    }

    return c.at(2);

  }

}

*/



//桁数を指定して出力する方法

//#include <iomanip>//これをincludeしておかないといけない

//cout << fixed << setprecision(20)<< ans << endl;



//  s.at(0) = toupper(s.at(0));//小文字なら大文字へ//大文字の場合はそのまま

//  s.at(i) = tolower(s.at(i));//大文字なら小文字へ//小文字の場合はそのまま

//getline(cin, s); //空白文字を含むものをまとめて入力できる。

//s配列に格納した単語を、辞書順にソートする

//  sort(s.begin(), s.end());

//  string t = ""keyence"";//で文字列を格納できる

//s.empty() //emptyなら1を出力 入っていれば0を出力

/*//ABC018-B 部分的にreverseをかける解法

int main() {

  string s; cin >> s;

  int n; cin >> n;

  vector<int>a(n); vector<int>b(n);

  rep(i,n) cin>>a.at(i)>>b.at(i);

  rep(i,n)a.at(i)--;  rep(i,n)b.at(i)--;

  string t;

  rep(i,n){

    t = s;

    for(int k=0;k<=b.at(i)-a.at(i);k++){

      t.at(a.at(i)+k) = s.at(b.at(i)-k);

    }

    s = t;

  }

  cout << s << endl;

}

*///ABC018-B

//  cout << char(i+48) << endl;//なぜかaは47と得る時がある。+48で出力もaにできる。

//  cout << char(97) << endl;//アスキーコードでaを出力

// sort(b.begin(), b.end());//bという配列を小さい方からソート

// reverse(b.begin(), b.end());//bという配列をリターン

/*01 02 03 12 13 23　と６回見ていくパターン 

for(int i=0;i<n-1;i++){

  for(int j=i+1;j<n;j++){

    }

  }

*/

//vector<vector<int>> a(3, vector<int>(4));//int型の2次元配列(3×4要素の)の宣言

//10のi乗pow(10, i);//ただしdouble型のため注意

/*string s; stringでの文字列を数字型に変える方法

  cin >> s;

  rep(i,s.size()-2) {

  int a= (s.at(i)-'0')*100 + (s.at(i+1)-'0')*10+ s.at(i+2) -'0';

*/

/*

  int n;

  cin >> n;

  vector<int>a(n);

  rep(i,n) cin >> a.at(i); 

*/

//cout << fixed << setprecision(10)<< ans << endl;

//数字から文字列に変換  a.at(0) = std::to_string(111);

#include <bits/stdc++.h>

#include <iomanip>//これをincludeしておかないといけない

#include <iostream>

#include <vector>

#include <queue>

using namespace std;

using Graph = vector<vector<int>>;

typedef long long ll;

typedef long double lld;

#define rep(i, n) for (int i = 0; i < (int)(n); i++)

#define PI 3.14159265359

//#define MOD 1000000007

#define MOD 998244353



int main(){

  int x;

  cin >> x;

  int ans = 0;

  if(x==1){

    cout << 1 << endl;

    return 0;

  }

  

  for(int i=2;i<=x;i++){

    int num = i;

    while(num <= x){

      num = num * i;

	    if(num <= x){

   	 	  ans = max(ans,num);

    	}

	  }

  }

  

  cout << ans << endl;

}",85.45,31.0,566.0,C++ (GCC 9.2.1),cpp
u053227023,p03352,C++,s660468349,2107.0,256.0,Time Limit Exceeded,"#include <iostream>

using namespace std;



int main() {

	int x, a = 1, b = 1;

	cin >> x;

	for(int i = 1; i < 35; i++){

		for(int j = i * i; j <= 10; j = j * i){

			if(j > a){

				a = j;

			}

		}

	}

	cout << a << endl;

	return 0;

}",99.95,16.0,20.0,C++14 (GCC 5.4.1),cpp
u053227023,p03352,C++,s306702413,1.0,256.0,Accepted,"#include <iostream>

using namespace std;



int main() {

	int x, a = 1, b = 1;

	cin >> x;

	if(x == 1){

		cout << 1 << endl;

		return 0;

	}

	for(int i = 2; i < 35; i++){

		for(int j = i * i; j <= x; j = j * i){

			if(j > a){

				a = j;

			}

		}

	}

	cout << a << endl;

	return 0;

}",99.95,16.0,20.0,C++14 (GCC 5.4.1),cpp
u054475353,p03352,C++,s311477762,4.0,384.0,Accepted,"#include<bits/stdc++.h>

#define ll long long 

#define inf 1000000007 

#define sort(vec) sort((vec).begin(),(vec).end());

#define rever(vec) reverse((vec).begin(),(vec).end());

#define unsort(vec) sort((vec)); rever((vec));

using namespace std;



int main() {

	int x;

	cin>>x;

	int lim=-100007;

	for(int i=1;i<=sqrt(x)+1;i++) {

		for(int j=1;j<=sqrt(x)+1;j++) {

			if(pow(i,j)<=x) {

				if(lim<pow(i,j)) {

					lim=pow(i,j);

				}

			}

		}

	}

	cout<<lim<<endl;

}",25.0,23.0,32.0,C++14 (GCC 5.4.1),cpp
u054475353,p03352,C++,s409613482,3.0,512.0,Accepted,"#include <bits/stdc++.h>

#define double long double

#define int long long

#define mii map<int,int>

#define pii pair<int,int>

#define low lower_bound

#define upp upper_bound

#define mod 1000000007 //10^9+7

#define inf 10000000000000000 //10^16

#define rep(i,n) for(int i=0;i<n;i++)

#define all(vec) vec.begin(),vec.end()

#define vsort(vec) sort(all(vec))

#define vrever(vec) reverse(all(vec));

#define vunsort(vec) vsort(vec); vrever(vec);

#define bisea binary_search

#define cend cout<<endl;

#define F first

#define S second

using namespace std;

signed main() {

	int x;

	cin>>x;

	int MAX=0;

	for(int i=0;i<=sqrt(x);i++) {

		for(int j=0;j<=sqrt(x);j++) {

			if(pow(i,j)<=x) {

				MAX=max(MAX,(int)pow(i,j));

			}

		}

	}

	cout<<MAX<<endl;

}
",25.0,23.0,32.0,C++14 (GCC 5.4.1),cpp
u058348416,p03352,C++,s055546055,2103.0,256.0,Time Limit Exceeded,"#include <bits/stdc++.h>

using namespace std;



int main(){

    int x, i, n, m = 1;

    cin >> x;

    int a[x+1] = {};

    for(i=1; i<=sqrt(x); i++){

        n = i;

        if(a[n] == 1){

            continue;

        }

        n *= i;

        while(n <= x){

            a[n] = 1;

            m = max(m, n);

            n *= i;

        }

    }

    cout << m;

    return 0;

}",99.95,22.0,22.0,C++14 (GCC 5.4.1),cpp
u058348416,p03352,C++,s998012068,1.0,256.0,Accepted,"#include <bits/stdc++.h>

using namespace std;



int main(){

    int x, i, n, m = 1;

    cin >> x;

    int a[x+1] = {};

    for(i=2; i<=sqrt(x); i++){

        n = i;

        if(a[n] == 1){

            continue;

        }

        n *= i;

        while(n <= x){

            a[n] = 1;

            m = max(m, n);

            n *= i;

        }

    }

    cout << m;

    return 0;

}",99.95,22.0,22.0,C++14 (GCC 5.4.1),cpp
u060306919,p03352,C++,s493283704,2103.0,512.0,Time Limit Exceeded,"#include <iostream>

#include <cmath>



using namespace std;



int main() {

    int X,t;

    cin >> X;

    t = X;



    for (int i = 0; i < X; ++i) {

        for (int j = X; j >= 1 ; --j) {

            for (int k = X; k >= 2; --k) {

                if (pow(j, k) == X) {

                    cout << pow(j, k);

                    return 0;

                }

            }

        }

        X--;

    }



    cout << t;









    return 0;

}",97.38,29.0,22.0,C++14 (GCC 5.4.1),cpp
u060306919,p03352,C++,s159317925,55.0,512.0,Accepted,"#include <iostream>

#include <cmath>



using namespace std;



int main() {

    int x, m = 1;

    cin >> x;



    for (int i = 1; i < x; ++i) {

        for (int j = 2; j < x; ++j) {

            if (pow(i, j) <= x && pow(i, j) >= m) {

                m = pow(i, j);

            }

        }

    }



    cout << m;





    return 0;

}",97.38,29.0,22.0,C++14 (GCC 5.4.1),cpp
u069669067,p03352,C++,s073754796,2103.0,128.0,Time Limit Exceeded,"#include <stdio.h>



int main(){

  int X;

  scanf(""%d"",&X);

  if(X<=3) {

    printf(""1"");

    return 0;

  }

  for(int l=X;l>0;l--){

    for(int i=1;i*i<=X;i++){

      if(l%i==0){

        int k=l;

        while(k!=1){

          if(k%i==0) k/=i;

          else break;

        }

        if(k==1&&l!=i) {printf(""%d"",l); return 0;}

      }

    }

  }

}
",99.95,22.0,22.0,C++14 (GCC 5.4.1),cpp
u069669067,p03352,C++,s897373655,1.0,128.0,Accepted,"#include <stdio.h>



int main(){

  int X;

  scanf(""%d"",&X);

  if(X<=3) {

    printf(""1"");

    return 0;

  }

  for(int l=X;l>0;l--){

    for(int i=2;i*i<=X;i++){

      if(l%i==0){

        int k=l;

        while(k!=1){

          if(k%i==0) k/=i;

          else break;

        }

        if(k==1&&l!=i) {printf(""%d"",l); return 0;}

      }

    }

  }

}
",99.95,22.0,22.0,C++14 (GCC 5.4.1),cpp
u072080927,p03352,C++,s729045780,2103.0,256.0,Time Limit Exceeded,"#include<bits/stdc++.h>

using namespace std;

int main(){

  int x,y;cin>>x;

  y=sqrt(x);

  vector<int>a(y);

  for(int i=0;i<y;i++){

    int k=i;

    while(true){

      k*=i;

      if(k>x){

        a.at(i)=k/i;

        break;

      }

    }

  }

  sort(a.begin(),a.end());

  cout<<a.at(a.size()-1)<<endl;

}",99.95,19.0,22.0,C++14 (GCC 5.4.1),cpp
u072080927,p03352,C++,s855358762,1.0,256.0,Accepted,"#include<bits/stdc++.h>

using namespace std;

int main(){

  int x,y;cin>>x;

  if(x>3){

    y=sqrt(x);

    vector<int>a(y);

    for(int i=1;i<y;i++){

      int k=i+1;

      while(true){

        k*=i+1;

        if(k>x){

          a.at(i)=k/(i+1);

          break;

        }

      }

    }

    sort(a.begin(),a.end());

    cout<<a.at(a.size()-1)<<endl;

  }

  else cout<<1<<endl;

}
",99.95,19.0,22.0,C++14 (GCC 5.4.1),cpp
u083912889,p03352,C++,s635035770,2.0,504.0,Accepted,"#include<queue>

#include<cstdio>

#include<cstring>

#include<iostream>

#include<algorithm>

using namespace std;

int x;

bool a[1001];

int main()

{

	a[1]=true;

	scanf(""%d"",&x);

	for (int i=2;i<=31;i++)

	{

		int j=i;

		while (j*i<=x)

		{

			j=j*i;

			a[j]=true;

		}

	}

	for (int i=x;i>0;i--)

		if (a[i])

		{

			printf(""%d"",i);

			break;

		}

	system(""pause"");

	return 0;

}
",50.0,30.0,30.0,C++14 (GCC 5.4.1),cpp
u083912889,p03352,C++,s590322188,1.0,256.0,Accepted,"#include<queue>

#include<cstdio>

#include<cstring>

#include<iostream>

#include<algorithm>

using namespace std;

int x;

bool a[1001];

int main()

{

	a[1]=true;

	scanf(""%d"",&x);

	for (int i=2;i<=31;i++)

	{

		int j=i;

		while (j*i<=x)

		{

			j=j*i;

			a[j]=true;

		}

	}

	for (int i=x;i>0;i--)

		if (a[i])

		{

			printf(""%d"",i);

			break;

		}

//	system(""pause"");

	return 0;

}
",50.0,30.0,30.0,C++14 (GCC 5.4.1),cpp
u084949493,p03352,C++,s255091521,9.0,3640.0,Accepted,"#include <bits/stdc++.h>

using namespace std;

#define rep(i, n) for (int i = 0; i < (int)(n); i++)

#define repr(i, a, b) for(int i = a; i < b; i++)

#define  all(x) (x).begin(),(x).end()     // 昇順ソート

#define  rall(v) (v).rbegin(), (v).rend() // 降順ソート

#define  FastIO ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0)

typedef long long ll;

typedef long long int lli;

template<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }

template<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return true; } return false; }



int dx[] = {1, 1, 0, -1, -1, -1, 0, 1};

int dy[] = {0, 1, 1, 1, 0, -1, -1, -1};



int main(){

    int x;

    cin >> x;

    vector<int> ans;

    ans.push_back(1);

    for(int i = 2; i * i <= x; i++){

        int num = i*i;

        while(num <= x){

            ans.push_back(num);

            num *= i;

        }

    }

    sort(rall(ans));

    cout << ans[0] << endl;

    return 0;

}",44.44,31.0,27.0,C++ (GCC 9.2.1),cpp
u084949493,p03352,C++,s592346580,5.0,3512.0,Accepted,"#include <bits/stdc++.h>

using namespace std;

#define rep(i, n) for (int i = 0; i < (int)(n); i++)

#define repr(i, a, b) for(int i = a; i < b; i++)

#define  all(x) (x).begin(),(x).end()     // 昇順ソート

#define  rall(v) (v).rbegin(), (v).rend() // 降順ソート

#define  FastIO ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0)

typedef long long ll;

using P = pair<int,int>;

template<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }

template<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return true; } return false; }



int main(){

    int x;

    cin >> x;

    int ans = 0;

    for(int b = 1; b <= 100; b++){

        for(int p = 2; p <= 10; p++){

            int y = 1;

            rep(i,p) y *= b;

            if (y <= x) ans = max(ans, y);

            else break;

        }

    }

    cout << ans << endl;

    return 0;

}",44.44,31.0,27.0,C++ (GCC 9.2.1),cpp
u089230684,p03352,C++,s071723486,2.0,256.0,Accepted,"#include<cstdio>

#include<algorithm>

#include<cmath>

using namespace std;

int x,ans,k;

int main(){

	scanf(""%d"",&x);

	if(x==1){printf(""1"");return 0;}

	for(int i=2;i<=x;++i){

		int j=2;

		k=pow(i,j);

		while(k<=x){

			ans=max(ans,k);

			if(ans==x){printf(""%d"",ans);return 0;}

			k=pow(i,++j);

		}

	}

	printf(""%d"",ans);

}",50.0,19.0,18.0,C++14 (GCC 5.4.1),cpp
u089230684,p03352,C++,s303926166,1.0,128.0,Accepted,"#include<cstdio>

using namespace std;

int num,t,ans=0;

int main() {

	scanf(""%d"", &t);

	for (int i = 1; i <= 31; ++i) {

		for (int j = 2; j <= 9; ++j) {

			num = 1;

			for (int k = 0; k < j; ++k) {

				num *= i;

			}

			if (num <= t && num > ans) {

				ans = num;

			}

		}

	}

	printf(""%d"",ans);

}",50.0,19.0,18.0,C++14 (GCC 5.4.1),cpp
u091552241,p03352,C++,s554305297,2104.0,133340.0,Time Limit Exceeded,"#include <bits/stdc++.h>

using namespace std;



int main(){

  int x;

  cin >> x;

  vector<int> vec;

  for(int i=1;i<32;i++){

    for(int j=2;;j++){

      if(pow(i,j)<=1000){vec.push_back(pow(i,j));}

      else{break;}

    }

  }

  sort(vec.begin(),vec.end());

  for(int i=0; i<vec.size(); i++){

    if(x<vec.at(i)){cout<<vec.at(i-1)<<endl;return 0;}

  }

}",99.9,18.0,19.0,C++14 (GCC 5.4.1),cpp
u091552241,p03352,C++,s267471919,2.0,512.0,Accepted,"#include <bits/stdc++.h>

using namespace std;



int main(){

  int x;

  cin >> x;

  if(x==1){cout << 1 << endl;return 0;}

  vector<int> vec;

  for(int i=2;i<32;i++){

    for(int j=2;;j++){

      if(pow(i,j)<=32*32){vec.push_back(pow(i,j));}

      else{break;}

    }

  }

  sort(vec.begin(),vec.end());

  for(int i=0; i<vec.size(); i++){

    if(x<vec.at(i)){cout<<vec.at(i-1)<<endl;return 0;}

  }

}
",99.9,18.0,19.0,C++14 (GCC 5.4.1),cpp
u097396733,p03352,C++,s613308606,2103.0,256.0,Time Limit Exceeded,"#include <bits/stdc++.h>

#include <string>

#include <algorithm>

#include <string.h>

using namespace std;

 

int main(){

    

    int X,max=1,tmp;

    cin >> X;



    for(int i=1;i<=100;i++){

        tmp=i;

        while(tmp<X){

            tmp=tmp*i;

        }

        tmp=tmp/i;

        if(tmp>max){

            max=tmp;

        }

    }



    cout << max <<endl;



    return 0;

}",99.95,26.0,26.0,C++14 (GCC 5.4.1),cpp
u097396733,p03352,C++,s561089051,1.0,256.0,Accepted,"#include <bits/stdc++.h>

#include <string>

#include <algorithm>

#include <string.h>

using namespace std;

 

int main(){

    

    int X,max=1,tmp;

    cin >> X;



    for(int i=1;i<=100;i++){

        tmp=i;

        for(int j=1;j<=100;j++){

            tmp=tmp*i;

            if(tmp>max&&tmp<=X){

            max=tmp;

            }

            if(tmp>X)break;

        }

    }



    cout << max <<endl;



    return 0;

}",99.95,26.0,26.0,C++14 (GCC 5.4.1),cpp
u108108663,p03352,C++,s460388234,2103.0,384.0,Time Limit Exceeded,"#include <bits/stdc++.h>

#define rep(i,n) for (int i = 0; i < (n); ++i)

using namespace std;

using ll = long long;

using P = pair<int,int>;



bool f(int a){

	for(int i = 1;i <= a;i++){

		for(int j = 2;j <= 1000;j++){

			if(pow(i,j) == a){

				return true;

			}

		}

	}

	return false;

}



int main(){

	int x;

	cin >> x;

	while(1){

		if(f(x)){

			cout << x << endl;

            return 0;

		}

		x--;

	}

}",98.43,28.0,28.0,C++14 (GCC 5.4.1),cpp
u108108663,p03352,C++,s945593250,33.0,256.0,Accepted,"#include <bits/stdc++.h>

#define rep(i,n) for (int i = 0; i < (n); ++i)

using namespace std;

using ll = long long;

using P = pair<int,int>;



bool f(int a){

	for(int i = 1;i <= a;i++){

		for(int j = 2;j <= 10;j++){

			if(pow(i,j) == a){

				return true;

			}

		}

	}

	return false;

}



int main(){

	int x;

	cin >> x;

	while(1){

		if(f(x)){

			cout << x << endl;

            return 0;

		}

		x--;

	}

}",98.43,28.0,28.0,C++14 (GCC 5.4.1),cpp
u110383054,p03352,C++,s251634663,2103.0,256.0,Time Limit Exceeded,"#include <iostream>

#include <cmath>



using namespace std;



int exponential(int a, int i) {

    if (i == 0)

        return 1;

    else

        return a * exponential(a, i-1);

}



int main() {

    int x;  cin >> x;

    int ans = 0;



    for (int a = 1; a <= sqrt(x); a++) {

        int tmp = a;

        while (tmp <= x) {

            ans = max(tmp, ans);

            tmp *= a;

        }

    }



    cout << ans << endl;



    return 0;

}",99.71,28.0,28.0,C++14 (Clang 3.8.0),cpp
u110383054,p03352,C++,s776605846,6.0,888.0,Accepted,"#include <iostream>

#include <cmath>



using namespace std;



int exponential(int a, int i) {

    if (i == 0)

        return 1;

    else

        return a * exponential(a, i-1);

}



int main() {

    int x;  cin >> x;

    int ans = 1;



    for (int a = 2; a <= sqrt(x); a++) {

        int tmp = a;

        while (tmp <= x) {

            ans = max(tmp, ans);

            tmp *= a;

        }

    }



    cout << ans << endl;



    return 0;

}",99.71,28.0,28.0,C++14 (Clang 3.8.0),cpp
u131340563,p03352,C++,s001558989,4.0,384.0,Accepted,"#include<iostream>

#include<string>

#include<algorithm>

#include<utility>

#include<cmath>

#include<vector>

#include<climits>

#define ll long long int

using namespace std;

int main(void) {

  int x;

  int ans=1;

  cin>>x;

  for(int i=2; i<=sqrt(x); i++) {

    for(int j=2; ; j++) {

      int y=pow(i, j);

      if(y>x) break;

      else ans = max(y, ans);

    }

  }

  cout<<ans<<endl;

  return 0;

}
",75.0,23.0,37.0,C++14 (GCC 5.4.1),cpp
u131340563,p03352,C++,s016683103,1.0,256.0,Accepted,"#include <algorithm>

#include <climits>

#include <iostream>

#include <string>

#include <utility>

#include <vector>

#include <set>

#include <map>

#include <queue>

#include <iomanip>

#include <cmath>

#include <stack>

#define rep(i,n) for (int i=0; i<(n); ++i)

using namespace std;

using ll = long long int;



template <class T> ostream &operator<<(ostream &os, vector<T> &v) {

  for (auto i = v.begin(); i != v.end(); i++) {

    os << *i << "" "";

  }

  return os;

}



const long long MOD = 1000000007;



int main(){

  int x;

  int ans = 1;

  cin>>x;

  for(int i=2; i*i<=x; i++) {

    int p=2;

    while(pow(i,p)<=x) p++;

    ans = max(ans, (int)pow(i,p-1));

  }

  std::cout << ans << std::endl;

  return 0;

}
",75.0,23.0,37.0,C++14 (Clang 3.8.0),cpp
u137747137,p03352,C++,s565386064,8.0,3624.0,Accepted,"#include <bits/stdc++.h>

using namespace std;

#define ll long long

#define ld long double

#define REP(i,m,n) for(int i=(int)(m); i<(int)(n); i++)

#define rep(i,n) REP(i,0,n)

#define RREP(i,m,n) for(int i=(int)(m); i>=(int)(n); i--)

#define rrep(i,n) RREP(i,(n)-1,0)

#define all(v) v.begin(), v.end()

#define endk '\n'

const int inf = 1e9+7;

const ll longinf = 1LL<<60;

const ll mod = 1e9+7;

const ld eps = 1e-10;

template<typename T1, typename T2> inline void chmin(T1 &a, T2 b){if(a>b) a=b;}

template<typename T1, typename T2> inline void chmax(T1 &a, T2 b){if(a<b) a=b;}



int main() {

  cin.tie(0);

  ios::sync_with_stdio(false);

  int x; cin >> x;

  int ans = 1;

  for(int i=2; i<x; i++) {

    ll tmp = i*i;

    while(true) {

      if(tmp > x) break;

      chmax(ans, tmp);

      tmp *= i;

    }

  }

  cout << ans << endk;

  return 0;

}
",25.0,33.0,31.0,C++ (GCC 9.2.1),cpp
u137747137,p03352,C++,s257826356,6.0,3616.0,Accepted,"#include <bits/stdc++.h>

using namespace std;

#define ll long long

#define ld long double

#define REP(i,m,n) for(int i=(int)(m); i<(int)(n); i++)

#define rep(i,n) REP(i,0,n)

#define RREP(i,m,n) for(int i=(int)(m); i>=(int)(n); i--)

#define rrep(i,n) RREP(i,(n)-1,0)

#define all(v) v.begin(), v.end()

#define endk '\n'

const int inf = 1e9+7;

const ll longinf = 1LL<<60;

const ll mod = 1e9+7;

const ld eps = 1e-10;

template<typename T1, typename T2> inline void chmin(T1 &a, T2 b){if(a>b) a=b;}

template<typename T1, typename T2> inline void chmax(T1 &a, T2 b){if(a<b) a=b;}



int main() {

  cin.tie(0);

  ios::sync_with_stdio(false);

  int x; cin >> x;

  int ans = 1;

  for(int i=2; i<=x; i++) {

    int tmp = i*i;

    if(tmp > x) continue;

    while(tmp*i <= x) tmp *= i;

    chmax(ans, tmp);

  }

  cout << ans << endk;

  return 0;

}
",25.0,33.0,31.0,C++ (GCC 9.2.1),cpp
u143536664,p03352,C++,s358098260,2103.0,128.0,Time Limit Exceeded,"#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

#include <stdlib.h>

#include <math.h>





int main() {

	int X,a;

	double x = 0;

	int Ans = 0,max = 0;



	scanf(""%d"", &X);



	for (int i = 1; i < 100; i++){

		for (int j = 2; j < 10; j++){

			x = pow(i, j);

			if ((x <= X)&&(x > max)){

				max = x;

				

			}



		}

	}

	if (max == 0){

		max = 1;

	}







	printf(""%d\n"", max);

	while (true)

	{



	}



	return 0;

}


",99.95,38.0,35.0,C++14 (GCC 5.4.1),cpp
u143536664,p03352,C++,s161145792,1.0,128.0,Accepted,"

#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

#include <stdlib.h>

#include <math.h>





int main() {

	int X,a;

	double x = 0;

	int Ans = 0,max = 0;



	scanf(""%d"", &X);



	for (int i = 1; i < 100; i++){

		for (int j = 2; j < 10; j++){

			x = pow(i, j);

			if ((x <= X)&&(x > max)){

				max = x;

				

			}



		}

	}

	if (max == 0){

		max = 1;

	}







	printf(""%d\n"", max);



	return 0;

}


",99.95,38.0,35.0,C++14 (GCC 5.4.1),cpp
u150167532,p03352,C++,s383032031,5.0,640.0,Accepted,"#include <iostream>

#include <vector>

#include <algorithm>

#include <string>

#include <cmath>



using namespace std;



int main() {

    

    int X;

    cin >> X;

    

    int ans=1;

    

    for(int b=1;b<=1000;b++){

        for(int p=2;p<=10;p++){

            if((pow(b,p)<=X)&&(pow(b,p)>=ans)){

                ans = pow(b,p);

            }

        }

    }

    

    cout << ans << endl;

    

    return 0;

}",60.0,27.0,34.0,C++14 (GCC 5.4.1),cpp
u150167532,p03352,C++,s798553866,2.0,384.0,Accepted,"#include <iostream>

#include <vector>

#include <algorithm>

#include <string>

#include <cmath>

#include <set>

#include <sstream>

#include <bitset>



#define FOR(i,a,b) for(int i=(a);i<(b);++i)

#define REP(i,n)  FOR(i,0,n)



typedef long long ll;



using namespace std;



int main() {

    

    int x;

    cin >> x;

    int ans=1;

    FOR(b, 2, 32){

        FOR(p, 2, 10){

            if((pow(b, p)>ans)&&(pow(b, p)<=x)){

                ans = pow(b, p);

            }

        }

    }

    

    cout << ans << endl;

    

    

    return 0;

}
",60.0,27.0,34.0,C++14 (GCC 5.4.1),cpp
u151855078,p03352,C++,s736626815,2103.0,256.0,Time Limit Exceeded,"#include <iostream>

#include <algorithm>

#include <vector>

#include <cmath>

#include <string>

using namespace std;

typedef long long ll;

typedef pair<int, int> pii;

const int mod = 1000000007;



int main() {

    ios::sync_with_stdio(false);

    int n, z = 0;

    cin >> n;

    for (int i = 1; i <= 328; i++) {

        int c = i;

        while (c * i <= n) c *= i;

        z = max(z, c);

    }

    cout << z;

}
",99.95,21.0,21.0,C++14 (GCC 5.4.1),cpp
u151855078,p03352,C++,s663142492,1.0,256.0,Accepted,"#include <iostream>

#include <algorithm>

#include <vector>

#include <cmath>

#include <string>

using namespace std;

typedef long long ll;

typedef pair<int, int> pii;

const int mod = 1000000007;



int main() {

    ios::sync_with_stdio(false);

    int n, z = 1;

    cin >> n;

    for (int i = 2; i <= 328; i++) {

        int c = i * i;

        while (c * i <= n) c *= i;

        if (c <= n) z = max(z, c);

    }

    cout << z;

}
",99.95,21.0,21.0,C++14 (GCC 5.4.1),cpp
u158620769,p03352,C++,s208395076,2103.0,256.0,Time Limit Exceeded,"#include<iostream>

#include<string>

#include<algorithm>

#include<vector>

#include<iomanip>

#include<math.h>

#include<complex>

#include<queue>

#include<deque>

#include<stack>

#include<map>

#include<set>

#include<bitset>

#include<functional>

using namespace std;

#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )

#define rep(i,n) REP(i,0,n)

typedef long long ll;

typedef pair<int,int> pint;

typedef pair<ll,int> pli;

const int inf=1e9+7;

const ll longinf=1LL<<60 ;

const ll mod=1e9+7 ;

#define SIZE_OF_ARRAY(a) (sizeof(a)/sizeof(a[0]))



unsigned GetDigit(unsigned num){

    return std::to_string(num).length();

}







int main(){

    cin.tie(0);

    ios::sync_with_stdio(false);

    int ans = 0;

    string ans2;

    int X;

    cin >> X;

    for(int i = 2;i < 1000;i--){

        for(int j = 1;j < 1000;j++){

            if(pow(j,i) > X && pow(j,i) > ans){

                ans = pow(j - 1,i);

                break;

            }

        }

    }

    end :

    cout << ans <<endl;

}",97.38,49.0,48.0,C++14 (GCC 5.4.1),cpp
u158620769,p03352,C++,s789910413,55.0,256.0,Accepted,"#include<iostream>

#include<string>

#include<algorithm>

#include<vector>

#include<iomanip>

#include<math.h>

#include<complex>

#include<queue>

#include<deque>

#include<stack>

#include<map>

#include<set>

#include<bitset>

#include<functional>

using namespace std;

#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )

#define rep(i,n) REP(i,0,n)

typedef long long ll;

typedef pair<int,int> pint;

typedef pair<ll,int> pli;

const int inf=1e9+7;

const ll longinf=1LL<<60 ;

const ll mod=1e9+7 ;

#define SIZE_OF_ARRAY(a) (sizeof(a)/sizeof(a[0]))



unsigned GetDigit(unsigned num){

    return std::to_string(num).length();

}







int main(){

    cin.tie(0);

    ios::sync_with_stdio(false);

    ll ans = 0;

    string ans2;

    ll X;

    cin >> X;

    for(ll i = 1000;i > 1;i--){

        for(ll j = 1000;j > 0;j--){

            if(pow(j,i) <= X && pow(j,i) > ans){

                ans = pow(j,i);

                break;

            }

        }

    }

    cout << ans <<endl;

}",97.38,49.0,48.0,C++14 (GCC 5.4.1),cpp
u179970156,p03352,C++,s697385457,2103.0,256.0,Time Limit Exceeded,"#include <iostream>

#include <algorithm>

using namespace std;



int main(){

  int n;

  cin >> n;

  int k=1000;

  for (int b=1;b<32;b++){

    int c=b;

    for (int p=2;p<10;p++){

      for (int i=1;i<p;i++){

        b=b*c;

      }

      if(n>=b){

        k=min(k,n-b);

      }

    }

  }

  cout << n-k << endl;

}

        ",99.95,22.0,22.0,C++14 (GCC 5.4.1),cpp
u179970156,p03352,C++,s736352048,1.0,256.0,Accepted,"#include <iostream>

using namespace std;



int heihou(int n){

  if(n==1||n==4||n==9||n==16||n==25||n==36||n==49||n==64||n==81||n==100||n==121||n==144||n==169||n==196||n==225||n==256||n==289||n==324||n==361||n==400||n==441||n==484||n==529||n==576||n==625||n==676||n==729||n==784||n==841||n==900||n==961||n==8||n==27||n==125||n==216||n==343||n==512||n==729||n==1000||n==32||n==243||n==128){

    return 1;

  }

  else{

    return 0;

  }

}



int main(){

  int n;

  cin >> n;

  for(int i=n;;i--){

    if(heihou(i)==1){

      cout << i << endl;

      break;

    }

  }

}",99.95,22.0,22.0,C++14 (GCC 5.4.1),cpp
u184929210,p03352,C++,s854883104,3.0,384.0,Accepted,"#include <bits/stdc++.h>

using namespace std;

#define rep(i, n) for(int i = 0; i < n; ++i)

#define ALL(v) v.begin(), v.end()

typedef long long ll;

typedef pair<int, int> P;

const int INF = 1000000007;



int main()

{

   int x;

   cin >> x;

   int ans = 1;

   for(int i = 2;i< x;i++)

   {

      int j = i * i;

      for(j;j<=x;j*=i)

      {

         ans = max(ans,j);

      }

   }

   cout<<ans<<endl;

   return 0;

}",66.67,24.0,18.0,C++14 (GCC 5.4.1),cpp
u184929210,p03352,C++,s792214948,1.0,256.0,Accepted,"#include<bits/stdc++.h>

using namespace std;

using ll = long long;



int main()

{

	int x;

	cin >> x;

	int ans = 1;

	for(int i = 2;i<=x;i++)

	{

		for(int j = i*i;j<=x;j*=i)

		{

			if(j<=x)ans= max(ans,j);

		}

	}

	cout<<ans<<endl;

}",66.67,24.0,18.0,C++14 (GCC 5.4.1),cpp
u188332959,p03352,C++,s408958523,9.0,3564.0,Accepted,"#include <bits/stdc++.h>

#define rep(i, n) for(int i = 0; i < (int)(n); i++)

using namespace std;

using ll = long long;

using P = pair<int,int>;



int main() {

  int x;

  cin >> x;

  int maxm = -1;

  for(int b = 1; b*b <= x; b++) {

    for(int q = 2; q <= 10; q++) {

      int ans = 1;

      rep(i, q) {

        ans *= b;

      }

      if(ans <= x) maxm = max(maxm, ans);

    }

  }

  cout << maxm << endl;

  return 0;

}

  ",44.44,23.0,25.0,C++ (GCC 9.2.1),cpp
u188332959,p03352,C++,s415928756,5.0,3604.0,Accepted,"#include <bits/stdc++.h>

#define rep(i, n) for(int i = 0; i < (int)(n); i++)

using namespace std;

using ll = long long;

using P = pair<int,int>;



int main() {

  int x;

  cin >> x;

  vector<bool> ok(x+1);

  ok[1] = true;

  for(int b = 2; b <= x; b++) {

    int v = b*b;

    while(v <= x) {

      ok[v] = true;

      v *= b;

    }

  }

  for(int i = x; i >= 1; i--) {

    if(ok[i]) {

      cout << i << endl;

      return 0;

    }

  }

}",44.44,23.0,25.0,C++ (GCC 9.2.1),cpp
u190875453,p03352,C++,s547162773,5.0,768.0,Accepted,"#include<bits/stdc++.h>

using namespace std;



typedef long long ll;

int main(){

  ll x;

  cin >> x;

  ll tmpans = 1;

  for(ll i = 1; i <= x; i++){

    ll tmp;

    for(ll j = 2; j < 10; j++){

      tmp = pow(i,j);

      if(tmp > x){

        break;

      }

      if(tmp > tmpans){

        tmpans = tmp;

      }

    }

  }

  

  cout << tmpans << endl;

  

}",20.0,24.0,28.0,C++14 (GCC 5.4.1),cpp
u190875453,p03352,C++,s854704608,4.0,640.0,Accepted,"#include <bits/stdc++.h>

using namespace std;





void solve(){



}



int main(){

    long long X;

    cin >> X;

    bool flg = false;

    long long ans = 1;

    for(long long i = X; i >= 0; i--){

        for(long long j = 2; j<= 33; j++){

            for(long long k = 2; k <= 10 && pow(j,k) <= 1000; k++){

                if( i == (long long)pow(j,k)){

                    flg = true;

                    ans = i;

                    break;

                }

            }

            if(flg) break;

        }

        if(flg) break;

    }

    cout << ans << endl;

}
",20.0,24.0,28.0,C++14 (GCC 5.4.1),cpp
u190907730,p03352,C++,s549400781,2103.0,256.0,Time Limit Exceeded,"#include<stdio.h>

#include<stdlib.h>

#include<iostream>

#include<string>

#include<algorithm>

#include<vector> 

#include<limits>

#include<numeric>

#include<type_traits>

#include<math.h>

using namespace std;

typedef long long ll;



#define rep(i, n) for(int i = 0; i < (int)(n); i++)

#define repi(i,a,b) for(int i = (int)(a); i < (int)(b); i++)

#define in(x) cin >> x

#define out(str) cout << str << endl



template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }

template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }



int X;

bool expo[1001];



int main(){

    cin>>X;

    rep(i,X+1){

        int a=i*i;

        while(a<=X){

            expo[a]=1;

            a*=i;

        }

    }

    repi(i,X,0){

        if(expo[i]){

            out(i);

            return 0;

        }

    }

}
",99.95,40.0,45.0,C++14 (GCC 5.4.1),cpp
u190907730,p03352,C++,s359864871,1.0,256.0,Accepted,"#include<stdio.h>

#include<stdlib.h>

#include<iostream>

#include<string>

#include<algorithm>

#include<vector> 

#include<limits>

#include<numeric>

#include<type_traits>

#include<math.h>

using namespace std;

typedef long long ll;



#define rep(i, n) for(int i = 0; i < (int)(n); i++)

#define repi(i,a,b) for(int i = (int)(a); i < (int)(b); i++)

#define in(x) cin >> x

#define out(str) cout << str << endl



template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }

template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }



int X,a;

bool expo[1001]={};



int main(){

    cin>>X;

    expo[1]=1;

    // rep(i,1001){

    //     expo[i]=0;

    // }

    repi(i,2,50){

        a=i*i;

        while(a<=X){

            expo[a]=1;

            a*=i;

        }

    }

    // out(expo[1000]);

    for(int i=X;;i--){

        if(expo[i]){

            out(i);

            return 0;

        }

    }

}
",99.95,40.0,45.0,C++14 (GCC 5.4.1),cpp
u192903163,p03352,C++,s716864309,4.0,512.0,Accepted,"#include <bits/stdc++.h>

#include <algorithm>

#include <iostream>

#include <stdio.h>

#include <math.h>

typedef long long ll;

using namespace std;



int main() {

	ll n,ans=0,p;

	cin >>n;

	if(n==1){

		cout << 1<<endl;

		return 0;

	}

	for(int i=1;i<=n/2;i++){

		for(int j=1;j<10;j++){

			p=pow(i,j);

			if(p<=n){

				ans=max(ans,p);

			}

		}

	}

	cout<<ans<< endl;

 	return 0;

}",75.0,26.0,24.0,C++14 (GCC 5.4.1),cpp
u192903163,p03352,C++,s283366155,1.0,256.0,Accepted,"#include <bits/stdc++.h>

#define be(v) (v).begin(),(v).end()

#define pb(q) push_back(q)

typedef long long ll;

using namespace std;

const ll mod=1000000007;



int main() {

    cin.tie(0);

    ios::sync_with_stdio(false);

    int n;

    cin>>n;

    int ma=1;

    int maki;

    for(int i=2;i<=n;i++){

        maki=i;

        while(maki*i<=n){

            maki*=i;

            ma=max(ma,maki);

        }

    }

    cout << ma<<endl;

    return 0;

}
",75.0,26.0,24.0,C++14 (GCC 5.4.1),cpp
u195010753,p03352,C++,s010020215,2103.0,4480.0,Time Limit Exceeded,"#include <cstdio>

#include <cmath>



int vis[1012];



int main(){

	int n;

	int ans;

	while(scanf(""%d"",&n)){

		ans = 0;	

		for(int i = 2;i <= (int)sqrt(n + 0.5) + 1;i++){

			for(int j = 1;pow(i,j) <= n;j++){

				if(pow(i,j) >= ans) ans = pow(i,j);

			}

		}

			printf(""%d"",ans);

	}

	





	return 0;

}








",99.9,26.0,24.0,C++14 (GCC 5.4.1),cpp
u195010753,p03352,C++,s300011864,2.0,512.0,Accepted,"#include <cstdio>

#include <cmath>





int main(){

	int n;

	scanf(""%d"",&n);

	int ans;

		ans = 1;	

		for(int i = 2;i <= (int)sqrt(n + 0.5) + 1;i++){

			for(int j = 1;pow(i,j) <= n;j++){

				if(pow(i,j) >= ans) ans = pow(i,j);

			}

		}

			printf(""%d"",ans);

	





	return 0;

}








",99.9,26.0,24.0,C++14 (GCC 5.4.1),cpp
